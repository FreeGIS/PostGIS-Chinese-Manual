{"./":{"url":"./","title":"Introduction","keywords":"","body":"PostGIS-Chinese-Manual PostGIS中文手册，富含大量实际案例和使用场景。 一 安装环境： 1.1 安装nodejs 1.2 全局安装gitbook npm install gitbook-cli -g 1.3 获取仓库并安装启动插件 git clone git@github.com:FreeGIS/PostGIS-Chinese-Manual.git cd PostGIS-Chinese-Manual gitbook install 1.4 启动项目 gitbook serve 页面预览地址：http://localhost:4000 "},"installation/PostgreSQL Installation.html":{"url":"installation/PostgreSQL Installation.html","title":"二 安装","keywords":"","body":"2.1 PostgreSQL安装 2.1.1 升级gcc 从镜像中下载较新的gcc压缩文件并解压： [root@ ~]# wget -c http://mirror.koddos.net/gcc/releases/gcc-9.2.0/gcc-9.2.0.tar.xz [root@ ~]# tar xvf gcc-9.2.0.tar.xz 下载并安装gcc依赖: [root@ ~]# cd gcc-9.2.0 [root@ gcc-9.2.0]# ./contrib/download_prerequisites 安装gcc，通过--prefix指定安装路径： [root@ gcc-9.2.0]# ./configure --prefix=/usr/local/gcc-9.2.0 --enable-checking=release --enable-languages=c,c++ --disable-multilib #服务器如果核数较多可以使用并行编译，比如有2核 # make -j 4 #-j后的并行数量应等于核数的2倍，不要太多。 [root@ gcc-9.2.0]# make -j 4 [root@ gcc-9.2.0]# make install 配置环境变量： [root@ gcc-9.2.0]# vi /etc/profile #将gcc加入path，注意path里有其他bin不要改，在后面追加，以免影响其他系统 export GCC_HOME=/usr/local/gcc-9.2.0 export PATH=$GDAL_HOME/bin:$GCC_HOME/bin:$PATH # :wq! 保存退出 #重启生效： [root@ gcc-9.2.0]# source /etc/profile 验证gcc安装： [root@ ~]# gcc --version gcc (GCC) 9.2.0 Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 移除低版本的yum安装的gcc，如果安装过将会卸载： [root@ ~]# yum remove gcc 更新系统库依赖，避免编译时发生glibcxx_x.x.xxx not found等lib包因版本差异导致的错误： #先全局查询libstdc++.so.6包所在位置 [root@ ~]# find / -name libstdc++.so.6 /usr/lib64/libstdc++.so.6 /usr/lib/libstdc++.so.6 /usr/local/gcc-9.2.0/lib64/libstdc++.so.6 #其中/usr/local是我们刚刚安装的，/lib与/lib64我们不清楚是不是残留，所以必须用新的直接替换即可。 [root@ ~]# cp /usr/local/gcc-9.2.0/lib64/libstdc++.so.6 /usr/lib [root@ ~]# cp /usr/local/gcc-9.2.0/lib64/libstdc++.so.6 /usr/lib64 2.1.2 其他依赖安装 [root@ ~]# yum install -y vim-enhanced.x86_64 gcc-java apr apr-devel openssl openssl-devel java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-devel.x86_64 perl-Module-Install.noarch readline-devel.x86_64 为了能在数据库中使用uuid，先要安装下uuid的库： # 下载uuid-1.6.2.tar.gz然后拷贝到安装服务器上。由于官方链接太烂，根本点不开，先暂时在百度网盘分享个资源： [uuid-1.6.2.tar.gz](https://pan.baidu.com/s/1NSHU8WrczfGDDsxYhEcAQQ) [root@ ~]# tar -zxvf uuid-1.6.2.tar.gz [root@ ~]# cd uuid-1.6.2 [root@ ~]# ./configure [root@ ~]# make [root@ ~]# make install 2.1.3 新建用户 [root@ ~]# useradd postgres 2.1.4 下载PG12源码编译安装 [root@ ~]# wget https://ftp.postgresql.org/pub/source/v12.1/postgresql-12.1.tar.gz [root@ ~]# tar -zxvf postgresql-12.1.tar.gz [root@ ~]# cd postgresql-12.1 [root@ postgresql-12.1]# ./configure --prefix=/home/postgres --enable-thread-safety --with-uuid=ossp --with-libs=/usr/local/lib --with-includes=/usr/local/include [root@ postgresql-12.1]# make -j 4 [root@ postgresql-12.1]# make install # 安装contrib工具包 [root@ postgresql-12.1]# cd contrib [root@ contrib]# make [root@ contrib]# make install 2.1.5 权限设置 #把程序安装目录全部赋权给postgres用户 [root@ contrib]# chown -R postgres.postgres /home/postgres/ 2.1.6 配置postgres用户环境变量 [root@ contrib]# su - postgres [postgres@ ~]$ vi .bashrc #编辑内容如下： PGHOME=/home/postgres export PGHOME PGDATA=$PGHOME/data export PGDATA PATH=$PATH:$HOME/.local/bin:$HOME/bin:$PGHOME/bin export PATH # wq! 保存退出 #重启生效 [postgres@ ~]$ source .bashrc 2.1.7 数据库初始化与启动 [postgres@ ~]$ initdb -D $PGDATA [postgres@ ~]$ pg_ctl start -D $PGDATA #登录数据库 [postgres@ ~]$ psql psql (12.1) Type \"help\" for help. postgres=# 到此为止，数据库已经完成安装，但只能本机连接，性能参数配置是默认的。有时候希望其他客户端也能连接，需要设置$PGDATA中的pg_hba.conf与postgresql.conf中相关参数，这些内容可以详细查看其他PG相关的博客和书籍。 "},"installation/PostGIS Installation.html":{"url":"installation/PostGIS Installation.html","title":"2.2 PostGIS安装","keywords":"","body":"2.2 PostGIS安装 本教程安装PostGIS 3.0,3.0依赖的库有geos,proj,gdal,libxml,json-c,protobuf，如何要支持三维需安装sfcgal，如果要做路网分析需安装pgrouting。 2.2.1 安装依赖 2.2.1.1 geos [root@ ~]# wget https://download.osgeo.org/geos/geos-3.8.0.tar.bz2 [root@ ~]# tar -jxvf geos-3.8.0.tar.bz2 [root@ ~]# cd geos-3.8.0 #指定目录安装 [root@ geos-3.8.0]# ./configure --prefix=/usr/local/geos-3.8.0 [root@ geos-3.8.0]# make -j 4 [root@ geos-3.8.0]# make install 2.2.1.2 proj [root@ ~]# wget http://download.osgeo.org/proj/proj-6.2.1.tar.gz [root@ ~]# tar -zxvf proj-6.2.1.tar.gz [root@ ~]# cd proj-6.2.1 #指定目录安装 [root@ proj-6.2.1]# ./configure --prefix=/usr/local/proj-6.2.1 [root@ proj-6.2.1]# make -j 4 [root@ proj-6.2.1]# make install 2.2.1.3 gdal [root@ ~]# wget https://download.osgeo.org/gdal/3.0.2/gdal-3.0.2.tar.gz [root@ ~]# tar -zxvf gdal-3.0.2.tar.gz [root@ ~]# cd gdal-3.0.2 #编译时间比较久，指定目录安装，且绑定已安装的pg [root@ gdal-3.0.2]# ./configure --prefix=/usr/local/gdal-3.0.2 --with-pg=/home/postgres/bin/pg_config [root@ gdal-3.0.2]# make -j 4 [root@ gdal-3.0.2]# make install 2.2.1.4 jsonc,libxml [root@ ~]# wget https://github.com/json-c/json-c/archive/json-c-0.13.1-20180305.tar.gz [root@ ~]# tar -zxvf json-c-0.13.1-20180305.tar.gz [root@ ~]# cd json-c-0.13.1-20180305 [root@ json-c-0.13.1-20180305]# ./configure --prefix=/usr/local/json-c-0.13.1 [root@ json-c-0.13.1-20180305]# make -j 4 [root@ json-c-0.13.1-20180305]# make install [root@ ~]# wget https://github.com/GNOME/libxml2/archive/v2.9.7.tar.gz [root@ ~]# tar -zxvf libxml2-sources-2.9.7.tar.gz [root@ ~]# cd libxml2-2.9.7 [root@ libxml2-2.9.7]# ./configure --prefix=/usr/local/libxml2-2.9.7 [root@ libxml2-2.9.7]# make -j 4 [root@ libxml2-2.9.7]# make install 2.2.1.5 protobuf,protobuf-c [root@ ~]# wget https://github.com/protocolbuffers/protobuf/archive/v3.10.1.tar.gz [root@ ~]# tar -zxvf protobuf-3.10.1.tar.gz [root@ ~]# cd protobuf-3.10.1 [root@ protobuf-3.10.1]# ./configure --prefix=/usr/local/protobuf-3.10.1 [root@ protobuf-3.10.1]# make -j 4 [root@ protobuf-3.10.1]# make install #配置环境变量，增加下protobuf-3.10.1/bin [root@ ~]# vi /etc/profile export PROTOBUF_HOME=/usr/local/protobuf-3.10.1 export PATH=$GCC_HOME/bin:$PROTOBUF_HOME/bin:$PATH #保存退出 [root@ ~]# source /etc/profile #验证protobuf执行程序 [root@ ~]# protoc --version libprotoc 3.10.1 #protobuf安装成功 [root@ ~]# wget https://github.com/protobuf-c/protobuf-c/releases/download/v1.3.2/protobuf-c-1.3.2.tar.gz [root@ ~]# tar -zxvf protobuf-c-1.3.2.tar.gz [root@ ~]# cd protobuf-c-1.3.2 #导入protobuf的pkgconfig，否则\"--No package 'protobuf' found\" [root@ protobuf-c-1.3.2]# export PKG_CONFIG_PATH=/usr/local/protobuf-3.10.1/lib/pkgconfig [root@ protobuf-c-1.3.2]# ./configure --prefix=/usr/local/protobuf-c-1.3.2 [root@ protobuf-c-1.3.2]# make -j 4 [root@ protobuf-c-1.3.2]# make install #配置环境变量，增加下protobuf-c-1.3.2/bin [root@ ~]# vi /etc/profile export PROTOBUF_HOME=/usr/local/protobuf-3.10.1 export PROTOBUFC_HOME=/usr/local/protobuf-c-1.3.2 export PATH=$GCC_HOME/bin:$PROTOBUF_HOME/bin:$PROTOBUFC_HOME/bin:$PATH #保存退出 [root@ ~]# source /etc/profile 2.2.1.6 sfcgal (三维场景，可选择安装) sfcgal需要cmkae编译，需先安装下cmake： [root@ ~]# wget https://github.com/Kitware/CMake/releases/download/v3.16.2/cmake-3.16.2.tar.gz [root@ ~]# tar -zxvf cmake-3.16.2.tar.gz [root@ ~]# cd cmake-3.16.2 [root@ cmake-3.16.2]# ./configure --prefix=/usr/local/cmake-3.16.2 [root@ cmake-3.16.2]# make -j 4 [root@ cmake-3.16.2]# make install #配置环境变量 [root@ ~]# vi /etc/profile export CMAKE_HOME=cmake-3.16.2 export PATH=$GCC_HOME/bin:$CMAKE_HOME/bin:$PROTOBUF_HOME/bin:$PROTOBUFC_HOME/bin:$PATH #保存退出 [root@ ~]# source /etc/profile sfcgal依赖boost,cgal，需要提前编译，编译默认目录，避免编译sfcgal时各种找不到库的问题。 [root@ ~]# yum install boost-devel [root@ ~]# wget https://github.com/CGAL/cgal/archive/releases/CGAL-4.13.tar.gz [root@ ~]# tar -zxvf CGAL-4.13.tar.gz [root@ ~]# cd CGAL-4.13 [root@ CGAL-4.13]# mkdir build && cd build #cmake不要指定安装路径 [root@ build]# cmake .. [root@ build]# make [root@ build]# make install 编译安装sfcgal： [root@ ~]# wget https://github.com/Oslandia/SFCGAL/archive/v1.3.7.tar.gz [root@ ~]# tar -zxvf v1.3.7.tar.gz [root@ ~]# cd SFCGAL-1.3.7 [root@ SFCGAL-1.3.7]# mkdir build & cd build [root@ build]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/sfcgal-1.3.7 .. [root@ build]# make -j 4 [root@ build]# make install pgrouting可以单独安装，在之后章目里会单独介绍。 2.2.2 PostGIS安装 2.2.2.1 配置ld.so.conf [root@ ~]# vim /etc/ld.so.conf #编辑内容如下 include ld.so.conf.d/*.conf /home/postgres/lib /usr/local/proj-6.2.1/lib /usr/local/gdal-3.0.2/lib /usr/local/geos-3.8.0/lib /usr/local//sfcgal-1.3.7/lib64 /usr/local/json-c-0.13.1/lib /usr/local/libxml2-2.9.7/lib /usr/local/protobuf-3.10.1/lib /usr/local/protobuf-c-1.3.2/lib #编辑完成后wq!保存退出 #保存配置，重启生效 [root@ ~]# ldconfig -v 2.2.2.2 安装postgis [root@ ~]# wget http://download.osgeo.org/postgis/source/postgis-3.0.0.tar.gz [root@ ~]# tar -zxvf postgis-3.0.0.tar.gz [root@ ~]# cd postgis-3.0.0 #根据安装不同的要求，选择任意一个configure #基本安装，不带sfcgal [root@ postgis-3.0.0]# ./configure --prefix=/home/postgres --with-gdalconfig=/usr/local/gdal-3.0.2/bin/gdal-config --with-pgconfig=/home/postgres/bin/pg_config --with-geosconfig=/usr/local/geos-3.8.0/bin/geos-config --with-projdir=/usr/local/proj-6.2.1 --with-xml2config=/usr/local/libxml2-2.9.7/bin/xml2-config --with-jsondir=/usr/local/json-c-0.13.1 --with-protobufdir=/usr/local/protobuf-c-1.3.2 # 带protobuf,sfcgal安装 [root@ postgis-3.0.0]# ./configure --prefix=/home/postgres --with-gdalconfig=/usr/local/gdal-3.0.2/bin/gdal-config --with-pgconfig=/home/postgres/bin/pg_config --with-geosconfig=/usr/local/geos-3.8.0/bin/geos-config --with-projdir=/usr/local/proj-6.2.1 --with-xml2config=/usr/local/libxml2-2.9.7/bin/xml2-config --with-jsondir=/usr/local/json-c-0.13.1 --with-protobufdir=/usr/local/protobuf-c-1.3.2 --with-sfcgal=/usr/local/sfcgal-1.3.7/bin/sfcgal-config [root@ postgis-3.0.0]# make -j 4 [root@ postgis-3.0.0]# make install 可能报错什么can not found lsqlite3等错误： yum instlal sqlite-devel 2.2.2.3 验证安装 [root@ ~]# su - postgres [postgres@ ~]$ psql psql (12.1) Type \"help\" for help. postgres=# create database mytest; CREATE DATABASE postgres=# \\c mytest You are now connected to database \"mytest\" as user \"postgres\". #验证postgis扩展 mytest=# create extension postgis; CREATE EXTENSION #验证栅格类数据需要的raster扩展 mytest=# create extension postgis_raster; CREATE EXTENSION #如果安装带有sfcgal，验证下三维sfcgal扩展 mytest=# create extension postgis_sfcgal; CREATE EXTENSION "},"vector_function/Accessors.html":{"url":"vector_function/Accessors.html","title":"八 矢量函数","keywords":"","body":"8.4 元数据读写 以下函数返回图形类型和图形类型对应的坐标和拓扑维度。 GeometryType 作用：返回图形类型字符串，字符串形式是：'POINT','LINESTRING','POLYGON','MULTIPOINT','MULTILINESTRING','MULTIPOLYGON'等等。 SELECT GeometryType(ST_GeomFromText('Point(118 32)')); geometrytype ------------------- POINT SELECT GeometryType(ST_GeomFromText('LineString(118 32,119 33)')); geometrytype ------------------- LINESTRING ST_GeometryType 作用：返回图形类型SQL_MM字符串，字符串形式是：'ST_Point','ST_Linestring','ST_Polygon','ST_MultiPoint','ST_MultiLinestring','ST_MultiPolygon'等等。 SELECT ST_GeometryType(ST_GeomFromText('Point(118 32)')); st_geometrytype ------------------- ST_Point SELECT ST_GeometryType(ST_GeomFromText('LineString(118 32,119 33)')); st_geometrytype ------------------- ST_Linestring ST_CoordDim/ST_NDims 作用：两个函数一模一样，都是返回图形坐标维度，如二维返回2，xyz,xym都返回3，xyzm返回4。 坐标形式 维度 xy 2 xyz 3 xym 3 xyzm 4 --xy SELECT ST_CoordDim(ST_GeomFromText('Point(1 2)')); st_coorddim ------------- 2 --xyz SELECT ST_CoordDim(ST_GeomFromText('PointZ(1 2 3')); st_coorddim ------------- 3 --xym SELECT ST_CoordDim(ST_GeomFromText('PointM(1 2 3')); st_coorddim ------------- 3 --xyzm SELECT ST_CoordDim(ST_GeomFromText('PointZM(1 2 2 2')); st_coorddim ------------- 4 ST_Dimension 作用：返回图形的拓扑维度，拓扑维度只区分大类，如POINT形式，子形式包括MULTIPOINT,POINTZ,POINTM,POINTZM，统统都返回0，以此类推。 几何拓扑形式 | 维度 ---|--- POINT | 0 LINESTRING | 1 POLYGON | 2 EMPTY | -1 --xy点 SELECT ST_CoordDim(ST_GeomFromText('Point(1 2)')); ST_Dimension ------------- 0 --multi点 SELECT ST_CoordDim(ST_GeomFromText('MultiPoint(1 2,3 4)')); ST_Dimension ------------- 0 --xyz点 SELECT ST_CoordDim(ST_GeomFromText('PointZ(1 2 3')); ST_Dimension ------------- 0 --xym点 SELECT ST_CoordDim(ST_GeomFromText('PointM(1 2 3')); ST_Dimension ------------- 0 --xyzm点 SELECT ST_CoordDim(ST_GeomFromText('PointZM(1 2 2 2')); ST_Dimension ------------- 0 --linestring SELECT ST_CoordDim(ST_GeomFromText('LineString(1 2,3 4)')); ST_Dimension ------------- 1 --polygon SELECT ST_CoordDim(ST_GeomFromText('Polygon((0 0,0 1,1 1,1 0,0 0))')); ST_Dimension ------------- 2 对于类型不明确的，如GEOMETRYCOLLECTION，会选择集合里维度最高的子图形，将该子图形的图形拓扑维度返回： SELECT ST_Dimension('GEOMETRYCOLLECTION(LINESTRING(1 1,0 0),POINT(0 0))'); ST_Dimension ----------- 1 SELECT ST_Dimension('GEOMETRYCOLLECTION(Polygon((0 0,0 1,1 1,1 0,0 0)),LINESTRING(1 1,0 0),POINT(0 0))'); ST_Dimension ----------- 2 ST_Zmflag 作用：该函数主要用于测试一个图形的坐标究竟是带m还是带z值，根据其不同转态返回能提现zm状态的维度编码。 zm坐标形式 | 维度 ---|--- xy | 0 xym | 1 xyz | 2 xyzm | 3 ST_Zmflag与ST_CoordDim,ST_NDims不同，ST_CoordDim,ST_NDims中，xyz与xym都返回3，xyzm返回4，这两个函数返回值只是表达了图形坐标是几维构成，但是同样是三维，究竟是xyz还是xym是区分不了的。而通过ST_Zmflag函数，能得到准确的图形坐标究竟是xyz还是xym形式。 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRING(1 2, 3 4)')); st_zmflag ----------- 0 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGM(1 2 0, 3 4 0)')); st_zmflag ----------- 1 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGZ(1 2 0, 3 4 0)')); st_zmflag ----------- 2 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGZM(1 2 0 0, 3 4 0 0)')); st_zmflag ----------- 3 --对比下ST_CoordDim,ST_NDims SELECT ST_CoordDim(ST_GeomFromEWKT('LINESTRINGZ(1 2 0, 3 4 0)')); ST_CoordDim ----------- 3 SELECT ST_CoordDim(ST_GeomFromEWKT('LINESTRINGM(1 2 0, 3 4 0)')); ST_CoordDim ----------- 3 --ST_CoordDim,ST_NDims无法区分第三维究竟是z还是m。 以下函数为测试函数，判别geometry某个属性是否具备某个状态。 ST_HasArc 作用：该函数主要用于测试一个图形是否包含圆弧。判断依据比较勉强，仅仅判断图形或者图形集合中的子图形是不是包含圆弧标志的字符串。 下例以CIRCULARSTRING(1 1, 2 2, 3 3, 4 4, 5 5)说明，这个圆弧长什么样都不知道，但是只要用CIRCULARSTRING声明其是圆弧，就会返回true。圆弧在PostGIS中其实能构造但是其他可视化软件不认识，无法可视化。该函数使用频率其实也非常低。 SELECT ST_HasArc(ST_GeomFromEWKT('CIRCULARSTRING(1 1, 2 2, 3 3, 4 4, 5 5)')); st_hasarc -------- true ST_IsPolygonCCW 作用：测试多边形是否具有逆时针方向的外环和顺时针方向的内环。 --外环是逆时针方向，内环是顺时针方向 select ST_IsPolygonCCW(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))')); ST_IsPolygonCCW ------------------- true --外环是逆时针方向，内环也是逆时针方向 select ST_IsPolygonCCW(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,2 1,2 2,1 2,1 1))')); ST_IsPolygonCCW ------------------- false ST_IsPolygonCW 作用：测试多边形是否具有顺时针方向的外环和逆时针方向的内环。 select ST_IsPolygonCW(ST_GeomFromEWKT('Polygon((0 0,0 3,3 3,3 0,0 0),(1 1,2 1,2 2,1 2,1 1))')); ST_IsPolygonCW ------------------- true ST_IsClosed 作用：判别一个线是否闭合。Polygon一定是闭合的否则构造会出错，因此，该函数常用就是判别线。所谓闭合，就是起点=终点 ，即首尾相连。 主要使用场景： SELECT ST_IsClosed(ST_GeomFromEWKT('LINESTRING(0 0, 1 1)')); st_isclosed ------------- false SELECT ST_IsClosed(ST_GeomFromEWKT('LINESTRING(0 0, 1 1,1 0,0 0)')); st_isclosed ------------- true 以下场景不常用，但是该函数也支持，并且返回结果有点差异。 多义线，每个子线都是首尾相连的： SELECT ST_IsClosed(ST_GeomFromEWKT('MULTILINESTRING((0 0, 1 1,1 0,0 0),(3 3,4 4,4 3,3 3))')); st_isclosed ------------- true 多义线，至少有个子线不是首尾相连的： SELECT ST_IsClosed(ST_GeomFromEWKT('MULTILINESTRING((0 0, 1 1,1 0,0 0),(3 3,4 4,4 3,3.5 3))')); st_isclosed ------------- true 结论：多义线实际是计算每个子线是否闭合，只有所有子线都闭合，才返回true，任意一个子线不闭合，就会返回false。 根据闭合的概念 起点=终点 那么对于点而言，起点终点就是一个点，所以一定返回true；而多义点和多义线一样，是分别计算每个子图形是否闭合，由于MultiPoint的子图形都是Point，而Point一定返回true，那么意味着于MultiPoint的子图形都是闭合的。 SELECT ST_IsClosed('POINT(0 0)'::geometry); st_isclosed ------------- true SELECT ST_IsClosed('MULTIPOINT((0 0), (1 1))'::geometry); st_isclosed ------------- true 结论： 1 对于点，多义点，该函数总是返回true。 2 对于线首尾相连认定闭合，多义线要保证每个子线都是闭合才认为多义线闭合。 3 对于面，多义面，由于面一定是闭合的，因此该函数总是返回true。 4 该函数其实仅仅用于判定LineString是否闭合为主要目的。 ST_IsCollection 作用：判定一个图形是否是集合类型，集合类型列表如下： • GEOMETRYCOLLECTION • MULTI{POINT,POLYGON,LINESTRING,CURVE,SURFACE} • COMPOUNDCURVE 当图形类型为列表类型时，该函数返回true，否则返回false。 --单线 SELECT ST_IsCollection('LINESTRING(0 0, 1 1)'::geometry); st_iscollection ------------- false --多义线 SELECT ST_IsCollection('MultiLINESTRING((0 0, 1 1))'::geometry); st_iscollection ------------- true ST_IsEmpty 作用：判定一个图形是否为空。 SELECT ST_IsEmpty(ST_GeomFromText('POLYGON EMPTY')); st_isempty ------------ true SELECT ST_IsEmpty(ST_GeomFromText('POLYGON((1 2, 3 4, 5 6, 1 2))')); st_isempty ------------ false ST_IsRing 作用：判定是否为“环”，图形中的换“环”其实是闭合的单线，比如Polygon就是一个个环组成的图形。对于“环”的定义应满足如下两点： 1 闭合的线，则ST_IsClosed(geom)=true。 2 该线不自相交，不自相切，则ST_IsSimple(geom)=true。 ​ SELECT ST_IsRing(geom), ST_IsClosed(geom), ST_IsSimple(geom) FROM (SELECT 'LINESTRING(0 0, 0 1, 1 1, 1 0, 0 0)'::geometry AS geom) AS foo; st_isring | st_isclosed | st_issimple -----------+-------------+------------- true | true | true SELECT ST_IsRing(geom), ST_IsClosed(geom), ST_IsSimple(geom) FROM (SELECT 'LINESTRING(0 0, 0 1, 1 0, 1 1, 0 0)'::geometry AS geom) AS foo; st_isring | st_isclosed | st_issimple -----------+-------------+------------- false | true | false 结论：由“环”定义可知，只有当则ST_IsClosed与则ST_IsSimple两个函数都返回true，ST_IsRing(geom)才会返回true。 ST_IsSimple 作用：判定一个图形是否自相交或者自相切。 示意图见ST_IsRing中示意图。 SELECT ST_IsSimple('LINESTRING(0 0, 0 1, 1 1, 1 0, 0 0)'::geometry); st_issimple ------------- true SELECT ST_IsSimple('LINESTRING(0 0, 0 1, 1 0, 1 1, 0 0)'::geometry); st_issimple ------------- false 以上函数为测试函数，判别geometry某个属性是否具备某个状态。 ST_Boundary 作用：返回图形边界，抽象，用例子说明。 1 对于点而言，图形边界都是empty： SELECT ST_AsText(ST_Boundary('Point(1 1)'::geometry)); st_astext ------------------------ GEOMETRYCOLLECTION EMPTY SELECT ST_AsText(ST_Boundary('MultiPoint(1 1,2 2)'::geometry)); st_astext ------------------------- GEOMETRYCOLLECTION EMPTY 2 对于未闭合线而言，图形边界是其起点和终点： SELECT ST_AsText(ST_Boundary('LINESTRING(1 1,2 2,3 -1)'::geometry)); st_astext ------------------------- MULTIPOINT(1 1,3 -1) SELECT ST_AsText(ST_Boundary('MultiLINESTRING((1 1,2 2,3 -1),(0 0,-1 -1,-2 3))'::geometry)); st_astext ------------------------------ MULTIPOINT(1 1,3 -1,0 0,-2 3) 补充：对MultiLINESTRING而言，分别计算子线的边界（起点，终点），然后把所有子线的边界（都是点）塞到一个MULTIPOINT返回。 3 对于闭合线，图形边界为空： SELECT ST_AsText(ST_Boundary('LINESTRING(1 1,2 2,3 -1,1 1)'::geometry)); st_astext ------------------------ MULTIPOINT EMPTY 4 对于面而言，图形边界是其环： 单义面： select ST_AsText(ST_Boundary(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))'))); st_astext ------------------------------------------------------------ MULTILINESTRING((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)) 多义面： select ST_AsText(ST_Boundary( ST_GeomFromEWKT('MultiPolygon(((0 0,1 0,1 1,0 1,0 0)),((2 2,2 3,3 3,3 2,2 2)))'))); st_astext ------------------------------------------------------------ MULTILINESTRING((0 0,1 0,1 1,0 1,0 0),(2 2,2 3,3 3,3 2,2 2)) ST_Envelope 作用：返回一个图形的外接矩形。点的外接矩形是Point，线面的外接矩形是个长方形Polygon，xyz的线面外接矩形仍然是xy维度里的长方形，而非官方手册说的长方体。 --点 SELECT ST_AsText(ST_Envelope('POINT(1 3)'::geometry)); st_astext ------------ POINT(1 3) --线 SELECT ST_AsText(ST_Envelope('LineString(0 0,1 1)'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) --面 SELECT ST_AsText(ST_Envelope('Polygon((0 0,1 0,1 1,0 1,0 0))'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) --xyz 线 SELECT ST_AsText(ST_Envelope('LineStringZ(0 0 0,1 1 1)'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) --xyz面 SELECT ST_AsText(ST_Envelope('PolygonZ((0 0 0,1 0 1,1 1 1,0 1 0,0 0 0))'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) 说明：xyz的线面返回还是二维的xy面，z轴被丢失了。 ST_Envelope与Box2D 相同点：ST_Envelope与Box2D都是获取输入图形的外接矩形。 不同点：ST_Envelope返回的是个geometry对象，如'Polygon((minx miny,minx maxy,maxx maxy,maxx miny,minx miny))::geometry'；Box2D返回的是box2d对象，如BOX(minx,miny,maxx,maxy)。 ST_BoundingDiagonal 作用：返回一个图形边界框构成的对角线。该函数会保留所有的srid和zm维度。 函数定义：ST_BoundingDiagonal(geometry geom, boolean fits=false) 参数说明：fits参数表示是否采用最佳拟合，在输入图形节点很多的情况下，fits=true则获取的边界框构成的对角线更精确点，但是稍慢；fits=false则获取的边界框范围稍大，但是速度更快。fits无论true或false，对角线构成的边界框都会覆盖输入图形（对角线的bbox>=输入图形的bbox） --xy SELECT ST_AsText(ST_BoundingDiagonal('Polygon((0 0,1 0,1 1,0 1,0 0))'::geometry)); st_astext --------------------------- LINESTRING(0 0,1 1) --xyz SELECT ST_AsText(ST_BoundingDiagonal('PolygonZ((0 0 0,1 0 1,1 1 1,0 1 0,0 0 0))'::geometry)); st_astext --------------------------- LINESTRING Z (0 0 0,1 1 1) ST_X,ST_Y,ST_Z,ST_M 作用：ST_X,ST_Y,ST_Z,ST_M四个函数分别返回Point的x，y，z，m值，入参必须是Point。 SELECT ST_X(geom), ST_Y(geom), ST_Z(geom),ST_M(geom) FROM (SELECT ST_GeomFromEWKT('POINT(1 2 3 4)') AS geom) AS foo; st_x | st_y | st_z | st_m -------------------------- 1 | 2 | 3 | 4 ST_StartPoint,ST_EndPoint 作用：ST_StartPoint,ST_EndPoint分别返回LineString或CircularLineString的起点，终点，入参必须是LineString与CircularLineString，如果是其他图形类型，返回null。 SELECT ST_AsText(ST_StartPoint(geom)) startpt, ST_AsText(ST_EndPoint(geom)) endpt FROM (SELECT ST_GeomFromEWKT('LINESTRING(0 0, 0 1, 1 0, 1 1)') AS geom) AS foo; startpt | endpt -------------------------- POINT(0 0) | POINT(1 1) SELECT ST_EndPoint('POINT(1 1)'::geometry) IS NULL AS is_null; is_null -------- true ST_NumGeometries,ST_GeometryN 作用：ST_NumGeometries返回一个图形集合中子图形的数量，ST_GeometryN返回图形集合中序号为n的子图形。两者关系类似与其他语言中获取数组的长度，根据索引返回数组中指定子项。 图形集合的概念：GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON, POLYHEDRALSURFACE。 索引序号：数据库中数组首项序号是1。与其他语言中数组首项序号为0有区别。 --获取图形集合中的子图形数量。 SELECT ST_NumGeometries(ST_GeomFromEWKT('GEOMETRYCOLLECTION( POINT(0 0), LINESTRING(0 0,1 1), POLYGON((0 0,1 0,1 1,0 1,0 0)))')); ST_NumGeometries --------------------------- 3 --获取图形集合中序号为2的子图形 SELECT ST_AsText(ST_GeometryN(ST_GeomFromEWKT('GEOMETRYCOLLECTION( POINT(0 0), LINESTRING(0 0,1 1), POLYGON((0 0,1 0,1 1,0 1,0 0)))'),2)); ST_GeometryN --------------------------- LINESTRING(0 0,1 1) --Multi类型 SELECT ST_NumGeometries(ST_GeomFromEWKT('MultiPOINT(0 0,1 1,2 2)')); ST_NumGeometries --------------------------- 3 SELECT ST_AsText(ST_GeometryN(ST_GeomFromEWKT('MultiPOINT(0 0,1 1,2 2)'),2)); ST_GeometryN --------------------------- POINT(1 1) ST_NRings,ST_ExteriorRing,ST_NumInteriorRings,ST_NumInteriorRing,ST_InteriorRingN 函数名称 作用 ST_NRings 返回Polygon的“环”数量，包括外环和内环 ST_NumInteriorRings 返回Polygon的“内环”数量 ST_NumInteriorRing 与ST_NumInteriorRings一模一样 ST_ExteriorRing 获取Polygon的外环(Polygon只有一个外环) ST_InteriorRingN 获取Polygon的指定序号的内环(Polygon可以有多个内环) 所谓“内环”就是面内组成孔洞的闭合线（孔洞边界线）。 限制说明：不用多想，只要记住这些函数仅支持Polygon类型。 --无孔洞 --该面就只有1个外环，内环数量0 SELECT ST_NRings(geom),ST_NumInteriorRings(geom) from (SELECT ST_GeomFromEWKT('Polygon((0 0,1 0,1 1,0 1,0 0))') AS geom) AS foo; ST_NRings | ST_NumInteriorRings -------------------------------------- 1 | 0 --有孔洞 --返回孔洞数量 SELECT ST_NRings(geom),ST_NumInteriorRings(geom) from (SELECT ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))') AS geom) AS foo; ST_NRings | ST_NumInteriorRings -------------------------------------- 2 | 1 --获取外环的图形 SELECT ST_AsText(ST_ExteriorRing(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))'))); ST_AsText ------------------------------- LINESTRING(0 0,3 0,3 3,0 3,0 0) --获取第一个孔洞的图形 SELECT ST_AsText(ST_InteriorRingN(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))'),1)); ST_AsText ------------------------------- LINESTRING(1 1,1 2,2 2,2 1,1 1) ST_NRings是支持MultiPolygon的： SELECT ST_NRings(ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)))')); ST_NRings ------------ 2 PostGIS官网说ST_NumInteriorRings支持MultiPolygon，返回MultiPolygon的第一个Polygon中的内环数量，但实测发现官网是错误的，ST_NumInteriorRings对MultiPolygon返回了null： SELECT ST_NumInteriorRings(ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)))')); ST_NumInteriorRings -------------------- null 结论：除ST_NRings支持MultiPolygon外，原则上这些函数都认为是只处理Polygon类型比较好，实际也的确只是用来处理Polygon的。 ST_NumPatches,ST_PatchN 函数名称 作用 ST_NumPatches 返回多面曲面上面的数量，对非多面曲面类型返回null ST_PatchN 返回多面曲面上指定序号为n的曲面，使用ST_GeometryN可以替代ST_PatchN，结果一样且查询更快 --返回曲面多面上面的数量 SELECT ST_NumPatches(ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )')); ST_NumPatches ------------ 6 --返回曲面多面上指定序号为n的曲面 SELECT ST_AsEWKT(ST_PatchN(geom, 2)) FROM (VALUES (ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )' )) ) As foo(geom); ST_AsEWKT ----------------------------------------- POLYGON((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0)) --其实使用ST_GeometryN可以替代ST_PatchN，结果一样。 ST_NPoints,ST_NumPoints,ST_PointN,ST_Points 函数名称 作用 ST_NPoints 返回geometry上Point点数量，不仅仅针对LineString。 ST_NumPoints 返回LineString或CircularString上节点数量，不支持Multi类型。 ST_PointN 返回LineString或CircularString指定序号为n的点，n=-1是终点。 ST_Points 返回geometry上所有Point点坐标，结果为MultiPoint形式。 --ST_NPoints SELECT ST_NPoints(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)')); ST_NPoints -------------- 3 SELECT ST_NPoints(ST_GeomFromText('Polygon((1 1,1 2,2 2,2 1,1 1))')); ST_NPoints -------------- 5 --ST_NumPoints SELECT ST_NumPoints(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)')); ST_NumPoints -------------- 3 SELECT ST_NumPoints(ST_GeomFromText('Polygon((1 1,1 2,2 2,2 1,1 1))')); ST_NumPoints -------------- null --序号为2 SELECT ST_AsText(ST_PointN(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'),2)); ST_AsText -------------- POINT(2 2) --序号为0 SELECT ST_AsText(ST_PointN(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'),0)); ST_AsText -------------- null --序号为-1 SELECT ST_AsText(ST_PointN(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'),-1)); ST_AsText -------------- POINT(3 4) --ST_Points select ST_AsText(ST_Points(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'))); ST_AsText ----------------------- MULTIPOINT(1 1,2 2,3 4) select ST_AsText(ST_Points(ST_GeomFromText('Polygon((1 1,1 2,2 2,2 1,1 1))'))); ST_AsText ------------------------------- MULTIPOINT(1 1,1 2,2 2,2 1,1 1) 结论：ST_NPoints和ST_NumPoints相同点是都获取图形的Point点数量；不同点是ST_NumPoints仅仅针对LineString或CircularString，而ST_NPoints还支持更多其他类型的图形。 ST_MemSize 作用：返回一个geom占用内存空间大小。 说明：ST_MemSize是PostgreSQL原生的pg_column_size, pg_size_pretty, pg_relation_size, pg_total_relatio_size等获取表或字段物理大小字段的补充，原因是原生函数不能准确表达geom的大小。 为什么不使用原生的pg函数去获取geometry或geom列或空间表的物理大小？由于geometry是个大对象，PG中对于大对象的物理存储提供了TOAST功能，只有了解TOAST的四种存储策略，才能理解为什么原生函数不适合，而要引入ST_MemSize，关于TOAS与PostGIS更多知识，请查看：待补充。 --单位是bytes，如果对象特别大，可以用pg_size_pretty函数显示的更人性化 --pg_size_pretty可以根据实际大小返回MB，GB等单位。 select ST_MemSize(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)')); ST_MemSize ---------- 80 ST_Summary 作用：以一个标准化的字符串描述一个图形的概要信息。 关键字： M: 图形坐标含有M值 Z: 图形坐标含有Z值 B: 有缓存bbox G: 图形为大地坐标 (geography) S: 图形有空间坐标系 SELECT ST_Summary(ST_GeomFromText('LINESTRING(0 0, 1 1)')) as geom1, ST_Summary(ST_GeomFromText('LINESTRINGM(0 0 0, 1 1 1)')) as geom2; geom1 | geom2 -------------------------------------------------------- LineString[] with 2 points | LineString[M] with 2 points select ST_Summary(ST_GeomFromText('LINESTRINGZ(0 0 0, 1 1 1)')) as geom3,ST_Summary(ST_GeomFromText('LINESTRING(0 0, 1 1)',4326)) as geom4; geom3 | geom4 -------------------------------------------------------- LineString[Z] with 2 points | LineString[S] with 2 points select ST_Summary(ST_GeogFromText('POLYGON((0 0, 1 1, 1 2, 1 1, 0 0))')) geog; geog -------------------------------- Polygon[BGS] with 1 ring: ring 0 has 5 points 注意：pg中数组都是从1开始计数的，在ST_InteriorRingN中n=1就是第一个外环。但是在ST_Summary返回的文本串里，第一个ring序号从0开始。 ST_Dump,ST_DumpPoints,ST_DumpRings 这三个函数返回值都是geometry_dump类型（缺少类型描述）的数据集。 函数名称 | 作用 ---|--- ST_Dump | 分解复杂组合图形 ST_DumpRings | 将Polygon分解成若干ring（环） ST_DumpPoints | 将图形分解成点 ST_Dump示例： --拆分集合 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_Dump(p_geom)) AS infos FROM ( SELECT ST_GeomFromEWKT('GEOMETRYCOLLECTION(LineString(0 0, 1 1, 1 0),LineString(1 0, 0 1))') AS p_geom) AS b) as a; path | geom ----------------------------------- {1} | LINESTRING(0 0,1 1,1 0) {2} | LINESTRING(1 0,0 1) --拆分多义线 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_Dump(p_geom)) AS infos FROM ( SELECT ST_GeomFromEWKT('MultiLineString((0 0, 1 1, 1 0),(1 0, 0 1))') AS p_geom) AS b) as a; path | geom -------------------------------- {1} | LINESTRING(0 0,1 1,1 0) {2} | LINESTRING(1 0,0 1) --拆分多义面 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_Dump(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0)),((1 1,1 2,2 2,2 1,1 1)))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1} | POLYGON((0 0,3 0,3 3,0 3,0 0)) {2} | POLYGON((1 1,1 2,2 2,2 1,1 1)) ST_DumpRings示例： select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_DumpRings(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1} | POLYGON((0 0,3 0,3 3,0 3,0 0)) {2} | POLYGON((1 1,1 2,2 2,2 1,1 1)) ST_DumpPoints分解成点的时候，path数组比较特殊，例如MultiPolygon拆分点后，path格式是{polygon_idx,ring_idx,pt_idx}，分别表达目前这个点在多义面中是哪个子面哪个子环哪个子节点上；而Polygon的path格式是{ring_idx,pt_idx},描述该点在面中位于哪个子环的哪个子节点；MultiLineString的path格式是{line_idx,pt_idx}，描述该点在多义线中位于哪个子线的哪个子节点；LineString的path格式就是{pt_idx}，很好理解。综述：path是描述这个点在图形中的层级关系的。 --多义面 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_DumpPoints(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1,1,1} | POINT(0 0) {1,1,2} | POINT(3 0) {1,1,3} | POINT(3 3) {1,1,4} | POINT(0 3) {1,1,5} | POINT(0 0) {1,2,1} | POINT(1 1) {1,2,2} | POINT(1 2) {1,2,3} | POINT(2 2) {1,2,4} | POINT(2 1) {1,2,5} | POINT(1 1) --单面 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_DumpPoints(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1,1} | POINT(0 0) {1,2} | POINT(3 0) {1,3} | POINT(3 3) {1,4} | POINT(0 3) {1,5} | POINT(0 0) {2,1} | POINT(1 1) {2,2} | POINT(1 2) {2,3} | POINT(2 2) {2,4} | POINT(2 1) {2,5} | POINT(1 1) "},"vector_function/Clustering.html":{"url":"vector_function/Clustering.html","title":"8.15 空间聚类","keywords":"","body":"ST_ClusterDBSCAN 方法功能描述 窗口函数，基于DBSCAN算法，返回每一个输入的geometry所对应的聚类id。 函数定义 integer ST_ClusterDBSCAN(geometry winset geom, float8 eps, integer minpoints); 入参： geom：输入的2d图形。 eps：聚类距离，当两个图形之间距离小于聚类距离，他们被归为一类。 minpoints：规定“簇”中至少包含的图形数量。 返回值：对应的聚类id号，如果输入的geom不属于任何一个“簇”，将返回null。 应用示例 从osm的building图层中截取了一小部分测试房屋建筑数据，基于ST_ClusterDBSCAN方法，根据建筑之间小于20米，且每一簇中至少包含2个图形： --表坐标系是epsg:4326的经纬度，所以这里是使用0.0002大概模拟20米，非真实距离。 SELECT gid,name, ST_ClusterDBSCAN(geom, eps:= 0.0002, minpoints := 2) over () AS cid FROM buildings; gid | name | cid -----+--------------+----- 1 | | 2 | | 2 3 | | 2 4 | | 2 5 | 大洋百货 | 6 | 商茂世纪广场 | 0 7 | 华威大厦 | 2 8 | 天安保险大厦 | 2 9 | | 2 10 | | 11 | 江苏交通大厦 | 2 12 | 阳光大厦 | 13 | | 0 14 | | 2 15 | | 2 16 | | 2 17 | | 2 18 | | 1 19 | | 1 20 | | 2 21 | | 2 22 | | 2 23 | | 2 24 | | 2 25 | | 2 26 | | 2 27 | | 2 -- More -- cid是每个geom所对应建筑的聚类id号，灰色建筑是与其他图形之间距离大于20米，所以没有归入任何一个“簇”，返回的聚类id是null(cid null的记录都是灰色的)。 ST_ClusterIntersecting 方法功能描述 聚合函数，对于输入的一个geometry集合，集合中图形之间根据“空间相交”进行聚类，最后把聚类结果聚合成一个geometry数组，数组里的每一项代表“一类”。 函数定义 geometry[] ST_ClusterIntersecting(geometry set g); 入参： g：输入的2d图形集合。 返回值：所有的图形完成聚类，每一类图形都是一个GEOMETRYCOLLECTION（图形集合）对象，所有类都塞入一个geometry数组里并返回结果。 应用示例 示例数据示意图如下： 先构造测试数据： create table building2( gid serial primary key, name text, geom geometry(Polygon,4326) ); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.77376608689 32.0424742122357,118.774542742962 32.0416518705121,118.773994515147 32.0411036426964,118.773172173423 32.0418802987687,118.77376608689 32.0424742122357))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.774222943403 32.0429310687489,118.775898083951 32.0413320709528,118.775456455989 32.0407838431371,118.774542742962 32.0416518705121,118.77376608689 32.0424742122357,118.774222943403 32.0429310687489))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.775898083951 32.0413320709528,118.777055453785 32.0402813009728,118.776629054372 32.0397635302578,118.775456455989 32.0407838431371,118.775898083951 32.0413320709528))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.771192461866 32.0393066737446,118.772684859809 32.0389259599839,118.772258460397 32.0379208756551,118.770705148252 32.0383320465169,118.771192461866 32.0393066737446))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.772258460397 32.0379208756551,118.772684859809 32.0389259599839,118.774375228908 32.0384234178194,118.773964058046 32.0375097047933,118.772258460397 32.0379208756551))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.776766111326 32.0381188468106,118.778045309563 32.0377076759488,118.778167137966 32.0373117336375,118.777695052903 32.0366721345192,118.776080826556 32.0371746766835,118.776766111326 32.0381188468106))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.778700137232 32.0380274755081,118.779857507065 32.0373878763897,118.779461564754 32.0368853342252,118.778730594333 32.0369614769774,118.778167137966 32.0373117336375,118.778045309563 32.0377076759488,118.778700137232 32.0380274755081))',4326)); 聚类结果示意图如下： 执行聚类： select st_astext(unnest(ST_ClusterIntersecting(geom))) from building2; st_astext ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- GEOMETRYCOLLECTION(POLYGON((118.77376608689 32.0424742122357,118.774542742962 32.0416518705121,118.773994515147 32.0411036426964,118.773172173423 32.0418802987687,118.77376608689 32.0424742122357)),POLYGON((118.774222943403 32.0429310687489,118.775898083951 32.0413320709528,118.775456455989 32.0407838431371,118.774542742962 32.0416518705121,118.77376608689 32.0424742122357,118.774222943403 32.0429310687489)),POLYGON((118.775898083951 32.0413320709528,118.777055453785 32.0402813009728,118.776629054372 32.0397635302578,118.775456455989 32.0407838431371,118.775898083951 32.0413320709528))) GEOMETRYCOLLECTION(POLYGON((118.771192461866 32.0393066737446,118.772684859809 32.0389259599839,118.772258460397 32.0379208756551,118.770705148252 32.0383320465169,118.771192461866 32.0393066737446)),POLYGON((118.772258460397 32.0379208756551,118.772684859809 32.0389259599839,118.774375228908 32.0384234178194,118.773964058046 32.0375097047933,118.772258460397 32.0379208756551))) GEOMETRYCOLLECTION(POLYGON((118.776766111326 32.0381188468106,118.778045309563 32.0377076759488,118.778167137966 32.0373117336375,118.777695052903 32.0366721345192,118.776080826556 32.0371746766835,118.776766111326 32.0381188468106)),POLYGON((118.778700137232 32.0380274755081,118.779857507065 32.0373878763897,118.779461564754 32.0368853342252,118.778730594333 32.0369614769774,118.778167137966 32.0373117336375,118.778045309563 32.0377076759488,118.778700137232 32.0380274755081))) (3 行记录) 使用问题 ST_ClusterIntersecting是个聚合函数，聚类的结果最后是一个geometry[]类型，没有任何属性字段，有时候我们其实聚类后，想要获取聚类图形结果与属性关系，比如我们没办法从ST_ClusterIntersecting函数的结果中输出对应的gid或者name等其他更多信息。 解决方法目前只能通过图形之间的关系去解决。 第一步：给原图形新增一列，存储一个必须在原图形内部的点： alter table building2 add column centroid geometry(point,4326); update building2 set centroid=ST_PointOnSurface(geom); 第二步：给聚类函数返回一个随机的聚类id： create extension \"uuid-ossp\"; --聚类中的每一组，都被分配了一个随机的聚类id create table temp_ClusterIntersecting( cid uuid, geom geometry ); insert into temp_ClusterIntersecting select uuid_generate_v4(),unnest(ST_ClusterIntersecting(geom)) from building2; 第三步：返回要素id和对应聚类id： select b.gid,a.cid a from temp_ClusterIntersecting a, building2 b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 4 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 5 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 6 | \"86daef2f-5cae-4a65-8208-433bf0c525e0\" 7 | \"86daef2f-5cae-4a65-8208-433bf0c525e0\" 也可以合起来写： select b.gid,a.cid from (select uuid_generate_v4() as cid,unnest(ST_ClusterIntersecting(geom)) as geom from building2) a, (select gid,ST_PointOnSurface(geom) as centroid from building2) b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 4 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 5 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 6 | \"86daef2f-5cae-4a65-8208-433bf0c525e0\" 这样，通过gid能关联得到每个记录对应的其他更多字段信息，通过cid知道哪些记录是一组的等其他操作。 注意：关于join和空间查询性能不是本节主要阐述重点，本节提出的方案是理论可行方案，但是基于实际项目和数据，存在优化空间，需要根据其他postgis优化方案进行处理。 ST_ClusterKMeans 方法功能描述 窗口函数，基于K-means算法，返回每一个输入的geometry所对应的聚类id。 函数定义 integer ST_ClusterKMeans(geometry winset geom, integer number_of_clusters); 入参： geom：输入的2d图形。 number_of_clusters：均值中心聚类指定“簇”的数量。 返回值：对应的聚类id号，如果输入的geom不属于任何一个“簇”，将返回null 应用示例 从osm的building图层中截取了一小部分测试房屋建筑数据，基于ST_ClusterKMeans空间聚合，指定分类数量为3，返回每个记录的id和对应的聚类id（cid）号： SELECT gid,ST_ClusterKMeans(geom,3) over () AS cid,geom FROM buildings; 指定分类数量为4： SELECT gid,ST_ClusterKMeans(geom,4) over () AS cid,geom FROM buildings; ST_ClusterWithin 方法功能描述 聚合函数，对输入的图形集合，如果图形之间的距离在指定的距离内，则归并为一类。与ST_ClusterIntersecting类似，只是ST_ClusterIntersecting指定是图形必须相交，可以认为距离是0，而ST_ClusterWithin不需要图形之间相交关系，而是说即使图形不相交，但是当图形的距离在所规定的容差内，就可认为他们是一类。 函数定义 geometry[] a(geometry set g, float8 distance); 入参： g：输入的2d图形集合。 distance：距离容差。 返回值：所有的图形完成聚类，每一类图形都是一个GEOMETRYCOLLECTION（图形集合）对象，所有类都塞入一个geometry数组里并返回结果。 应用示例 从osm的building图层中截取了一小部分测试房屋建筑数据，基于ST_ClusterWithin空间聚类，指定聚类条件是图形间的距离小于50米： select unnest(ST_ClusterWithin(geom, 0.0005)) geom from buildings; 指定聚类条件是图形间的距离小于30米： select unnest(ST_ClusterWithin(geom, 0.0003)) geom from buildings; 使用问题 ST_ClusterWithin是个聚合函数，聚类的结果最后是一个geometry[]类型，没有任何属性字段，有时候我们其实聚类后，想要获取聚类图形结果与属性关系，比如我们没办法从ST_ClusterWithin函数的结果中输出对应的gid或者name等其他更多信息。 解决方法目前只能通过图形之间的关系去解决。 第一步：给原图形新增一列，存储一个必须在原图形内部的点： alter table buildings add column centroid geometry(point,4326); update buildings set centroid=ST_PointOnSurface(geom); 第二步：给聚类函数返回一个随机的聚类id： create extension \"uuid-ossp\"; --聚类中的每一组，都被分配了一个随机的聚类id create table temp_ClusterWithin( cid uuid, geom geometry ); insert into temp_ClusterWithin select uuid_generate_v4(),unnest(ST_ClusterWithin(geom，0.0005)) from buildings; 第三步：返回要素id和对应聚类id： select b.gid,a.cid a from temp_ClusterWithin a, buildings b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" (More rows) 也可以合起来写： select b.gid,a.cid from (select uuid_generate_v4() as cid,unnest(ST_ClusterWithin(geom，0.0005))) as geom from buildings) a, (select gid,ST_PointOnSurface(geom) as centroid from buildings) b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" (More rows) 这样，通过gid能关联得到每个记录对应的其他更多字段信息，通过cid知道哪些记录是一组的等其他操作。 注意：关于join和空间查询性能不是本节主要阐述重点，本节提出的方案是理论可行方案，但是基于实际项目和数据，存在优化空间，需要根据其他postgis优化方案进行处理。 "},"vector_function/LinearReferencing/ST_LineInterpolatePoint.html":{"url":"vector_function/LinearReferencing/ST_LineInterpolatePoint.html","title":"8.16 线性参考","keywords":"","body":"ST_LineInterpolatePoint 方法功能描述 根据百分比返回单义线上任意点的位置。 函数定义 geometry ST_LineInterpolatePoint(geometry a_linestring, float8 a_fraction); 入参： a_linestring：一条线，必须是LineString类型，不支持MultiLineString； a_fraction：百分比，0-1之间的一个小数。 返回值： 一个点图形对象。 应用示例 返回线的中点位置： --中点对应的百分比是0.5，起点对应0，终点对应1 SELECT ST_AsText(ST_LineInterpolatePoint(the_line, 0.50)) FROM (SELECT ST_GeomFromText('LINESTRING(118 32,119 33)') as the_line) As foo; st_astext ------------------- POINT(118.5 32.5) (1 行记录) 返回线的起点位置： SELECT ST_AsText(ST_LineInterpolatePoint(the_line, 0)) FROM (SELECT ST_GeomFromText('LINESTRING(118 32,119 33)') as the_line) As foo; st_astext ------------------- POINT(118 32) (1 行记录) 返回线的终点位置： SELECT ST_AsText(ST_LineInterpolatePoint(the_line, 1)) FROM (SELECT ST_GeomFromText('LINESTRING(118 32,119 33)') as the_line) As foo; st_astext ------------------- POINT(119 33) (1 行记录) 多维应用 ST_LineInterpolatePoint函数能部分满足多维应用，PostGIS中常用的有 经度纬度高程(lon,lat,z)这样的三维数据，还有 经度纬度测量值(lon,lat,m)这样的测量值坐标。分别举例如下： --带高程z SELECT ST_AsText(ST_LineInterpolatePoint(the_line, 0.5)) FROM (SELECT ST_GeomFromText('LINESTRINGZ(1 1 6, 3 1 3, 3 3 8)') as the_line) As foo; st_astext ------------------- POINT Z(3 1 3) (1 行记录) --带测量值m SELECT ST_AsText(ST_LineInterpolatePoint(the_line, 0.5)) FROM (SELECT ST_GeomFromText('LINESTRINGM(1 1 6, 3 1 3, 3 3 8)') as the_line) As foo; st_astext ------------------- POINT M(3 1 3) (1 行记录) --既有高程z，也有测量值m SELECT ST_AsText(ST_LineInterpolatePoint(the_line, 0.5)) FROM (SELECT ST_GeomFromText('LINESTRINGZM(1 1 6 8, 3 1 3 6, 3 3 8 7)') as the_line) As foo; st_astext ------------------- POINT M(3 1 3 6) (1 行记录) 现象：ST_LineInterpolatePoint只是根据经纬度和百分比算位置的，无论后面z还和m是什么值对于平面的中点位置其实没有任何影响。计算出实际位置后，才插值计算该点对应的z，m值。 说明：位置点的计算，与高程z毫无关系，其实等于说明，不支持真实的带高程z的三维图形计算，三维中的位置点计算另有函数实现。 ST_3dLineInterpolatePoint 该函数使用与ST_LineInterpolatePoint一模一样，但是支持三维高程数据，下面举几个案例说明： 高程z计算 SELECT ST_AsText(ST_3dLineInterpolatePoint(the_line, 0.5))FROM (SELECT ST_GeomFromText('LINESTRINGZ(1 1 6, 3 1 3, 3 3 8)') as the_line) As foo; st_astext ----------------------------------------------- POINT Z (3 1.33046593658801 3.82616484147003) (1 行记录) 说明：计算结果不同于ST_LineInterpolatePoint，ST_3dLineInterpolatePoint计算结果已经考虑了三维z值对位置的影响。 测量值m计算 SELECT ST_AsText(ST_3dLineInterpolatePoint(the_line, 0.5))FROM (SELECT ST_GeomFromText('LINESTRINGM(1 1 6, 3 1 3, 3 3 8)') as the_line) As foo; st_astext ----------------------------------------------- POINT M(3 1 3) (1 行记录) 说明：线型为LINESTRINGM，没有申明z值，此为特殊情况，可以理解成线上的点的z值都是同一个默认值z（比如0），那么在默认值z的维度下（降维打击？？？），这个线其实是个标准的平面二维数据，所以ST_3dLineInterpolatePoint与ST_LineInterpolatePoint结果一致。 例如，当z值相同，可以看成在该维度下是二维的，位置点经纬度结果与二维是一致： SELECT ST_AsText(ST_3dLineInterpolatePoint(the_line, 0.5))FROM (SELECT ST_GeomFromText('LINESTRINGZ(1 1 6, 3 1 6, 3 3 6)') as the_line) As foo; st_astext ----------------------------------------------- POINT M(3 1 6) (1 行记录) 高程z与测量值m计算 SELECT ST_AsText(ST_3dLineInterpolatePoint(the_line, 0.5))FROM (SELECT ST_GeomFromText('LINESTRINGZM(1 1 6 5, 3 1 3 4, 3 3 8 9)') as the_line) As foo; st_astext ----------------------------------------------- POINT ZM (3 1.33046593658801 3.82616484147003 4.82616484147003) (1 行记录) 说明：ST_3dLineInterpolatePoint函数根据经纬度和高程z计算出三维点位置，再根据点位置反向插值计算m值。 总结： ST_LineInterpolatePoint位置点由经纬度参与计算，高程z与测量m值不参与计算。位置点确定后，反向插值计算z，m，仅适合二维。 ST_3dLineInterpolatePoint位置点有经纬度和高程z参与计算，测量值m不参与计算。位置点确定后，反向插值计算m，仅适合三维。 测量值m都不参与位置点计算，而是通过已经计算出的位置点，反向插值推导出该点对应的m值。 ST_LineInterpolatePoints 方法功能描述 根据百分比返回单义线上一到多个的任意点的位置。 函数定义 geometry ST_LineInterpolatePoints(geometry a_linestring, float8 a_fraction,boolean repeat); 入参： a_linestring：一条线，必须是LineString类型，不支持MultiLineString； a_fraction：百分比，0-1之间的一个小数。 repeat：true可重复，如设置0.1，则从0开始，每0.1间隔采一个点；如设置0.6，即使true也只会有一个点。false时等同与ST_LineInterpolatePoint。 返回值： 一到多个点图形对象。返回多个点时是MultiPoint对象，单个点时是Point对象。 使用示例： 设置fraction=0.5，即每0.5位置获取一个点： SELECT ST_AsText(ST_LineInterpolatePoints(the_line, 0.5)) FROM (SELECT ST_GeomFromText('LINESTRING(1 1, 3 1, 3 3)') as the_line) As foo; st_astext ----------------------------------------------- MULTIPOINT(3 1,3 3) (1 行记录) 设置fraction=0.6： SELECT ST_AsText(ST_LineInterpolatePoints(the_line, 0.6)) FROM (SELECT ST_GeomFromText('LINESTRING(1 1, 3 1, 3 3)') as the_line) As foo; st_astext ----------------------------------------------- POINT(3 1.4) (1 行记录) "},"vector_function/LinearReferencing/ST_LineLocatePoint.html":{"url":"vector_function/LinearReferencing/ST_LineLocatePoint.html","title":"ST_LineLocatePoint","keywords":"","body":"ST_LineLocatePoint 方法功能描述 已知一条线和某个点，该点可在线上，也可以不在线上，当点不在线上时，实际上是先从线上计算出与该点最近的点，然后计算位于线上这个点位于线上的[0,1]之间的一个百分比。 函数定义 float8 ST_LineLocatePoint(geometry a_linestring, geometry a_point); 参数定义： a_linestring：一条线，LineString及其扩展类型LineStringZ，LineStringM或者LineStringZM，但是不重要，zm都不会参与计算。 a_point：一个已知点。 使用限制：该函数只适用二维，根本不会考虑三维情况。 应用示例 点在线上常规操作： select ST_LineLocatePoint(st_geomfromtext('LineString(1 1,3 1,3 3)'), st_geomfromtext('Point(3 1)')); st_lineLocatepoint ------------------ 0.5 带z值： select ST_LineLocatePoint(st_geomfromtext('LineStringZ(1 1 6,3 1 3,3 3 8)'), st_geomfromtext('PointZ(3 1 5)')); st_lineLocatepoint ------------------ 0.5 带m值： select ST_LineLocatePoint(st_geomfromtext('LineStringM(1 1 6,3 1 3,3 3 8)'), st_geomfromtext('PointM(3 1 5)')); st_lineLocatepoint ------------------ 0.5 带zm值： select ST_LineLocatePoint(st_geomfromtext('LineStringZM(1 1 6 5,3 1 3 4,3 3 8 5)'), st_geomfromtext('PointZM(3 1 5 5)')); st_lineLocatepoint ------------------ 0.5 点不在线上： select ST_LineLocatePoint(st_geomfromtext('LineString(1 1,3 1,3 3)'), st_geomfromtext('Point(3 4)')); st_lineLocatepoint ------------------ 1 select ST_LineLocatePoint(st_geomfromtext('LineString(1 1,3 1,3 3)'), st_geomfromtext('Point(2.5 2.5)')); st_lineLocatepoint ------------------ 0.875 结论：符合使用限制说明，仅仅用于二维，zm值对计算结果无影响。点不在线上时，实际等同于先根据ST_ClosestPoint函数计算该点对应线上的一个最近点，然后使用最近点计算其在线上的百分比。 典型应用场景 单独使用这个函数比较少，都是结合其他函数一起使用。比如在路径分析中，有起点终点，得到一个完整的路径，路径是由路段拼接的，而起点终点不一定就在路段上，首尾就会有时长一部分有时短一截，显示效果比较差，如下图： 通过ST_LineLocatePoint计算出起点终点在路径上的百分比，然后调用ST_SubString函数根据百分截取一个子路段，可以优化这样的效果，如下图： sql示例： do language plpgsql $$ DECLARE line geometry; --路径 start geometry; --起点 end geometry; --终点 startfraction float; endfraction float; route_path geometry; --最终路径结果 BEGIN line=ST_GeomFromText('LineString(1 1,5 5)'); start:=ST_MakePoint(1.5,1.8); end:=ST_MakePoint(4.9,5.1); startfraction:=ST_LineLocatePoint(line,start); endfraction:=ST_LineLocatePoint(line,end); route_path:=ST_LineSubstring(line,startfraction,endfraction); raise notice '%',st_astext(route_path); end; $$; "},"vector_function/LinearReferencing/ST_LineSubstring.html":{"url":"vector_function/LinearReferencing/ST_LineSubstring.html","title":"ST_LineSubstring","keywords":"","body":"ST_LineSubstring 方法功能描述 根据输入的0-1之间的两个分数，截取两个分数之间的一个子线，使用方式很像字符串截取的函数。 函数定义 geometry ST_LineSubstring(geometry a_linestring, float8 startfraction, float8 endfraction); a_linestring:输入线，必须是LineString及其扩展LineStringM，LineStringZ，LineStringZM类型。 startfraction：0-1之间的一个百分比数。 endfraction：0-1之间的一个百分比数。 当startfraction=endfraction，ST_LineSubstring结果等同于ST_LineInterpolatePoint，仅仅返回一个点。 应用示例 startfraction SELECT ST_AsText(ST_LineSubString(ST_GeomFromText('LINESTRING(118 32,119 33)'), 0.333, 0.666)); st_astext ---------------------------------------- LINESTRING(118.333 32.333,118.666 32.666) startfraction=endfraction SELECT ST_AsText(ST_LineSubString(ST_GeomFromText('LINESTRING(118 32,119 33)'), 0.333, 0.333)); st_astext ---------------------- POINT(118.333 32.333) 当startfraction=endfraction时，ST_LineSubString结果等同于ST_LineInterpolatePoint函数的要实现的功能。 startfraction>endfraction SELECT ST_AsText(ST_LineSubString(ST_GeomFromText('LINESTRING(118 32,119 33)'),0.666, 0.333)); ERROR: 错误: 2nd arg must be smaller then 3rd arg 结论：startfraction一定要小于等于endfraction。 连续的MULTILINESTRINGs 说明：ST_LineSubString仅仅支持LineString及其衍生类型，不支持MULTILINESTRING及其衍生类型。 所以有种特殊情况下，即MULTILINESTRING中的子线都是连续的，那么他们可以合并成一个新的LineString结果。 SELECT ST_AsText(ST_LineSubString(ST_LineMerge(ST_GeomFromText('MULTILINESTRING((118 32,118.5 32.5),(118.5 32.5,119 33))')),0.333, 0.666)); st_astext ---------------------------------------------------- LINESTRING(118.333 32.333,118.5 32.5,118.666 32.666) 由于(118 32,118.5 32.5),(118.5 32.5,119 33)两个子线是连续的，当ST_LineMerge时，会形成一个新的单线LineString(118 32,118.5 32.5,119 33)，以上函数实际是对该LineString做的分段线提取。 "},"vector_function/LinearReferencing/ST_LocateAlong.html":{"url":"vector_function/LinearReferencing/ST_LocateAlong.html","title":"ST_LocateAlong","keywords":"","body":"ST_LocateAlong 方法功能描述 已知一个非面的带M值的图形，输入任意一个M测量值，返回该M值对应的地理位置集合形成的一个图形对象，返回图形都是MULTIPOINTM类型。 函数定义 不输入偏移量： geometry ST_LocateAlong(geometry ageom_with_measure, float8 a_measure); 输入偏移量： geometry ST_LocateAlong(geometry ageom_with_measure, float8 a_measure, float8 offset); 参数定义： ageom_with_measure：必须是POINTM，MULTIPOINTM，LINESTRINGM，MULTILINESTRINGM类型之一，不支持面数据。POINTM只有单个点其实没啥意义，实际可用类型就MULTIPOINTM，LINESTRINGM，MULTILINESTRINGM三种类型，实用类型通常就LINESTRINGM一种情况。 a_measure：测量值数值。 offset：偏移量，意思是生成后的图形相对于原来图形进行偏移，正值是代表生成后的图形相当于原来图形左偏移，负值是相当于原来图形右偏移。 函数定义和说明非常非常抽象！！！ 使用限制：该函数有且仅适用于带测量值M的非面状图形计算。 应用示例 简单线型 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('LINESTRINGM(1 2 4, 3 4 2, 9 4 3)'),3) As the_geom) As foo; st_astext ----------- MULTIPOINT M (2 3 3,9 4 3) 多义线型 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('MULTILINESTRINGM((1 2 3, 3 4 2, 9 4 3),(1 2 3,5 4 5))'),3) As the_geom) As foo; st_astext -------------------------------- MULTIPOINT M (1 2 3,9 4 3,1 2 3) 结果出现了两个（1 2 3）点，原因是上图MULTILINESTRINGM由子线1,2组成的，在计算时，实际会将多义线拆分成单义线，每条线单独计算，从子线1得到 （1 2 3），（9 4 3）两个点，从子线2得到（1 2 3）一个点，合计得到3个点。 多义点类型 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('MULTIPointM(1 2 3, 3 4 2, 9 4 3)'),3) As the_geom) As foo; st_astext -------------------------------- MULTIPOINT M (1 2 3,9 4 3) SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('MULTIPointM(1 2 3, 3 4 2, 9 4 3)'),2.3) As the_geom) As foo; st_astext -------------------------------- MULTIPOINT M EMPTY 多义点不会插值，m值只有“碰”到这个点的m值才行，不会插值，碰不到就返回空。 单点类型 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('PointM(1 2 3)'),3) As the_geom) As foo; st_astext --------------------- MULTIPOINT M (1 2 3) SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('MULTIPointM(1 2 3)'),2.3) As the_geom) As foo; st_astext -------------------- MULTIPOINT M EMPTY 单点和多义点一样，不会插值，m值只有“碰”到这个点的m值才行，不会插值，碰不到就返回空。 简单线型偏移值 --正向偏移 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('LINESTRINGM(1 2 4, 3 4 2, 9 4 3)'),3,1) As the_geom) As foo; st_astext --------------------------------------------------------- MULTIPOINT M (1.29289321881345 3.70710678118655 3,9 5 3) 沿着单义线的前进方向，对原来的结果点向左偏移距离1，形成两个新的结果点。 --负向偏移 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('LINESTRINGM(1 2 4, 3 4 2, 9 4 3)'),3,-1) As the_geom) As foo; st_astext --------------------------------------------------------- MULTIPOINT M (2.70710678118655 2.29289321881345 3,9 3 3) 多义线型偏移值 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('MULTILINESTRINGM((1 2 3, 3 4 2, 9 4 3),(1 2 3,5 4 5))'),3,1) As the_geom) As foo; st_astext --------------------------------------------------------- MULTIPOINT M (0.292893218813453 2.70710678118655 3,9 5 3,0.552786404500042 2.89442719099992 3) 由图可知，即使偏移量，也是分别根据子线1，子线2分别做的偏移。红蓝箭头构成的直角框可知。 "},"vector_function/LinearReferencing/ST_LocateBetween.html":{"url":"vector_function/LinearReferencing/ST_LocateBetween.html","title":"ST_LocateBetween","keywords":"","body":"ST_LocateBetween 方法功能描述 已知一个有测量值的图形，设置一个起点，终点测量值构成的区间，返回区间内的衍生图形集合。 函数定义 geometry ST_LocateBetween(geometry geom, float8 measure_start, float8 measure_end, float8 offset); 入参： geom：带有测量值的M的图形。 measure_start：起点测量值。 measure_end：终点测量值。 offset：偏移量，不指定默认值为0，当偏移量为正，偏移方向是相对于原图形的左边偏移；当偏移量为负，偏移方向相对于原图形的右边偏移。 注意：该函数支持LineString,MultiLineString,POLYGON,MultiPOLYGON,TIN, TRIANGLE图形类型，这些图形必须都带有M测量值。 应用示例 MULTILINESTRINGM 查询m值在1.5到3之间的图形集合，对于子线(1 2 3, 3 4 2, 9 4 3)所有的点m值都大于1.5；对于子线(1 2 3, 5 4 5)只有(1 2)点的M值等于3符合，其他都大于3，不符合。 SELECT ST_AsText(the_geom) FROM ( SELECT ST_LocateBetween( ST_GeomFromtext('MULTILINESTRING M ((1 2 3, 3 4 2, 9 4 3),(1 2 3, 5 4 5))'), 1.5, 3) as the_geom) As foo; st_astext ----------------------------------------------------------------------- GEOMETRYCOLLECTION M (LINESTRING M (1 2 3,3 4 2,9 4 3),POINT M (1 2 3)) 偏移值 --偏移值1是原图形的左边偏移。 SELECT ST_AsText(the_geom) FROM ( SELECT ST_LocateBetween( ST_GeomFromtext('MULTILINESTRING M ((1 2 3, 3 4 2, 9 4 3),(1 2 3, 5 4 5))'), 1.5, 3,1 ) as the_geom ) As foo; --偏移值-1是原图形的右边偏移。 偏移值方向不同，拐角处理原则不同，有圆角和直角，同时，会对部分图形进行合并，比如不偏移会有一个(1 2)单独的点，偏移后被合并到偏移线上了，没有单独的点了。 POLYGONM 从一个面中查询测量值2.5到3之间的面区域。 SELECT ST_AsText(the_geom) FROM ( SELECT ST_LocateBetween( ST_GeomFromtext('POLYGON M ((1 2 3, 1 4 2, 3 4 3,3 2 2,1 2 3))'), 2.5, 3) as the_geom) As foo; st_astext ----------------------------------------------------------------------- MULTIPOLYGON M (((1 2 3,1 3 2.5,2 4 2.5,3 4 3,3 3 2.5,2 2 2.5,1 2 3))) 换成multipolygon: SELECT ST_AsText(the_geom) FROM ( SELECT ST_LocateBetween( ST_GeomFromtext('MultiPOLYGON M (((1 2 3, 1 4 2, 3 4 3,3 2 2,1 2 3)))'), 2.5, 3) as the_geom) As foo; st_astext ----------------------------------------------------------------------- MULTIPOLYGON M (((1 2 3,1 3 2.5,2 4 2.5,3 4 3,3 3 2.5,2 2 2.5,1 2 3))) "},"vector_function/LinearReferencing/ST_LocateBetweenElevations.html":{"url":"vector_function/LinearReferencing/ST_LocateBetweenElevations.html","title":"ST_LocateBetweenElevations","keywords":"","body":"ST_LocateBetweenElevations 方法功能描述 已知一个有高程值z的图形，设置一个起点，终点z值构成的区间，返回区间内的衍生图形集合。该函数与ST_LocateBetween本质一样，只是ST_LocateBetween是处理二维图形含测量值M的情况，计算方式是依据二维几何计算；ST_LocateBetweenElevations是处理三维图形含高程值Z的情况，计算方式是依据三维几何计算。 函数定义 geometry ST_LocateBetweenElevations(geometry geom, float8 elevation_start, float8 elevation_end); 参数定义： geom:输入的一个带有高程值z的图形。LineString，Polygon，TIN, TRIANGLE图形类型。 elevation_start：起点海拔。 elevation_end：终点海拔。 应用示例 LineString SELECT ST_AsTexT(ST_LocateBetweenElevations( ST_GeomFromText('LINESTRINGZ(1 2 3, 4 5 6)'), 2, 4)) As ewelev; ewelev ---------------------------------------------------------------- MULTILINESTRING Z ((1 2 3,2 3 4)) Polygon 从一个高程面中查询高程值2.5到3之间的面区域。 SELECT ST_AsText(the_geom) FROM ( SELECT ST_LocateBetweenElevations( ST_GeomFromtext('POLYGONZ((1 2 3, 1 4 2, 3 4 3,3 2 2,1 2 3))'), 2.5, 3) as the_geom) As foo; st_astext ----------------------------------------------------------------------- MULTIPOLYGON Z (((1 2 3,1 3 2.5,2 4 2.5,3 4 3,3 3 2.5,2 2 2.5,1 2 3))) "},"vector_function/LinearReferencing/ST_InterpolatePoint.html":{"url":"vector_function/LinearReferencing/ST_InterpolatePoint.html","title":"ST_InterpolatePoint","keywords":"","body":"ST_InterpolatePoint 方法功能描述 已知一个带M的LineString图形，及其任意点，通过插值计算返回该点对应的M值。 函数定义 float8 ST_InterpolatePoint(geometry line, geometry point); 参数定义： line:输入的一个带有高程值z的图形必须是LineStringM类型，其他图形类型还有高程z都不支持！！！ point：任意点，可以在线上或者不在线上。 返回值： 返回参数点对应的测量值。 应用示例 点在线上 SELECT ST_InterpolatePoint(st_geomfromtext('LINESTRING M (0 0 0, 10 0 20)'), st_geomfromtext('POINT(5 0)')); ST_InterpolatePoint -------------------------- 10 点不在线上 SELECT ST_InterpolatePoint(st_geomfromtext('LINESTRING M (0 0 0, 10 0 20)'), st_geomfromtext('POINT(5 5)')); ST_InterpolatePoint -------------------------- 10 说明：当点不在线上时，实际是先计算参数点到线上最近的点，然后使用最近的点计算测量值M，最后这个M值赋予参数点，结束。 "},"vector_function/LinearReferencing/ST_AddMeasure.html":{"url":"vector_function/LinearReferencing/ST_AddMeasure.html","title":"ST_AddMeasure","keywords":"","body":"ST_AddMeasure 方法功能描述 已知一条线，通过在起点设置一个测量值，终点设置一个测量值的方式，从而对线上任意位置线性插值了测量值。如果线图形没有测量值，将添加测量值，如果线图形已有测量值，将会被新计算后的测量值“替换”。 函数定义 geometry ST_AddMeasure(geometry geom_mline, float8 measure_start, float8 measure_end); 参数定义： geom_mline：对输入的线进行添加测量值操作，必须是LineString或MultiLinString类型。 measure_start:测量值起点，该值对应输入线的起点。 measure_end:测量值终点，该值对应输入线的终点。 返回值：LineStringM或MultiLinStringM带M值图形。 API示例 LineString SELECT ST_AsText(ST_AddMeasure( ST_GeomFromEWKT('LINESTRING(118 32, 119 32, 121 32)'),1,4)) As ewelev; ST_AsText ----------------------------------------- LINESTRING M (118 32 1,119 32 2,121 32 4) 结论：没有测量值，将会对线添加测量值。 LineStringM SELECT ST_AsText(ST_AddMeasure( ST_GeomFromEWKT('LINESTRINGM(118 32 7, 119 32 8, 121 32 10)'),1,4)) As ewelev; ST_AsText ----------------------------------------- LINESTRING M (118 32 1,119 32 2,121 32 4) 结论：已有测量值，将会用新测量值“替换”旧测量值。 MultiLineString SELECT ST_AsText(ST_AddMeasure( ST_GeomFromEWKT('MULTILINESTRING((118 32,119 32,121 32),(118 33, 119 33, 121 33))'),1,7)) As ewelev; 注意：第一个子线的最后一个点是(121 32 4)与第二个子线第一个点(118,33,4)，测量值都是4，这是什么原因？ 原理：ST_AddMeasure函数是把第二个子线的起点拼接到第一个子线的终点，那么可以121 32和118 33硬凑一起了。 那么第二条子线(118 33, 119 33, 121 33)就会变成(121 32,122 32,124 32)。 拼接到一起，然后计算测量值，然后再把测量值对应写会第二条子线上。 错误使用场景 新闻广播中常常有这样的报道：距离xx高速入口30公里处发生交通事故，这时地图上有个闪动的事故点，标明事故地点。为了实现这些功能，某技术人员对一条道路，其图形为线LineString(119 30,120.22 30.22,120.33 30.33)添加地理长度测量值，这条线起点（等同高速入口的意思）位置为0，终点设置为线的球面距离，这样，当计算某事故点距离起点多少米时，可以快速获取点的坐标位置。 第一步：计算线的真实长度： select ST_Length(ST_GeomFromText('LineString(119 30,120.22 30.22,120.33 30.33)',4326)::geography); ST_Length ------------------ 136231.99705736412 第二步：给线添加测量值： select ST_AsText(ST_AddMeasure( ST_GeomFromText('LineString(119 30,120.22 30.22,120.33 30.33)',4326),0,136231.99705736412)); st_astext ------------------------------------------------------------------------------------ LINESTRING M (119 30 0,120.22 30.22 121042.702052768,120.33 30.33 136231.997057364) 第三步：验证结果： 建立测量值后，[120.22 30.22]点处测量值M为121042.702052768。 计算起点线到[120.22 30.22]点真实球面距离为120085.05682156245。 select ST_Length(ST_GeomFromText('LineString(119 30,120.22 30.22)',4326)::geography); ST_Length ------------------ 120085.05682156245 ==技术人员结论：[120.22 30.22]测量值M与真实距离不一致。== 错误原因：终点处是通过geography类型计算的球面距离，但是ST_AddMeasure函数入参只能是geometry类型，导致球面距离线性插值到平面的geometry图形上，于是，在节点处导致测量值M与ST_Length不一致。 验证想法：线路长度使用平面长度，把平线长度的结果线性插值到平面线图形上： --平面geometry距离 select ST_Length(ST_GeomFromText('LineString(119 30,120.22 30.22,120.33 30.33)',4326)); ST_Length ------------------ 139524.0869245977 --平面距离，添加测量值 select ST_AsText(ST_AddMeasure( ST_GeomFromText('LineString(119 30,120.22 30.22,120.33 30.33)',4326),0,139524.0869245977)); st_astext ------------------------------------------------------------------------------------ LINESTRING M (119 30 0,120.22 30.22 123967.737738494,120.33 30.33 139524.086924598) --起点到[120.22 30.22]处的平面距离 select ST_Length(ST_GeomFromText('LineString(119 30,120.22 30.22)',4326)); ST_Length ------------------ 123967.737738494 结论：都统一使用平面距离后，线性插值的M值与实际计算的平面长度一致。因此，ST_AddMeasure不会导致计算结果出现差异，差异是平面球面理解不深，混合杂用导致计算维度不统一形成差异。 ==引申：然而平面距离的确不是球面距离，如果就是使用球面距离计算位置，如何计算？假设我们要求距离起点60000米（真实地理距离，球面距离）的位置点坐标。== --先计算整条线球面长度 select ST_Length(ST_GeomFromText('LineString(119 30,120.22 30.22,120.33 30.33)',4326)::geography); ST_Length ------------------ 136231.99705736412 --计算60000米占总长度的百分比。 select 60000/136231.99705736412 as per; per ---------------------- 0.44042516659823608027 --根据百分比定位 SELECT ST_AsText(ST_LineInterpolatePoint(ST_GeomFromText('LineString(119 30,120.22 30.22,120.33 30.33)',4326), 0.44042516659823608027)); ST_AsText --------------------------------------- POINT(119.604745257323 30.1090524234517) "},"vector_function/LinearReferencing/examples.html":{"url":"vector_function/LinearReferencing/examples.html","title":"综合案例","keywords":"","body":"背景 在对线性参考函数进行研究的时候，一直试图找一个综合点（系统点）的使用案例。但是很可惜在我以往的工程经验里面很少有使用到此类函数的场景，更为系统的使用就更加稀少。我也思考过这个问题，这个看起很高级的用法，但是使用的人很少呢？我想无外乎就是以下几点： 对数据的要求，线性参考避免对一个整体的数据进行切分保证的几何的连续性。但是几何数据是由测绘部门一段一段测绘得来，本身就是分开（不连续）。所以需要使用线性参考，就需要数据部门处理成合适的数据，这需要测绘与数据生产部门积极配合，这属于第一道坎。 开发人员大多数时候都只是响应产品经理或者业主的需求，而本质上线性参考是一种数据结构，是一种非常巧妙的数据结构。既然是数据结构，那就对产品经理或者业主是隔离的，他们是不知道这个东西的，他们思考的时候那就依然用熟悉的方式思考，这是第二道坎。 对于开发人员来说，线性参考使用的较少，积累的经验是不足的，对于系统的设计也是有挑战的。所以开发人员也会倾向于不使用该方法。 案例 场景描述 用线性参考描述高速公路里程的问题。 1、 纯几何 这种情况数据部门只提供一条几何线，所有里程全部是根据几何特性计算而来。这是最舒服的一个使用场景，完全是几何逻辑。而且计算结果和理论上的值是一样的，在这种情况是完全是没问题的。 with test_table as (select geom as line, ST_LineInterpolatePoint(geom,0.1) as point, st_length(geom::geography) as length from test_line) select ST_InterpolatePoint(ST_AddMeasure(line,0,length),point),length/10 from test_table ------- 17465.740134863605 | 17465.740134864067 2、 半几何 这种情况数据部门提供了一条几何线的同时，也提供了起点的里程，也就是这个里程不是从0开始。这种情况也是容易处理，只需要将ST_AddMeasure函数的输入给调整一下就OK。 with test_table as (select geom as line, ST_LineInterpolatePoint(geom,0.1) as point, st_length(geom::geography) as length,ST_LineInterpolatePoint(geom,0) as point0 ,ST_LineInterpolatePoint(geom,1) as point1 from test_line) select ST_InterpolatePoint(ST_AddMeasure(line,1000,length+1000),point),length/10,point from test_table 3、 非几何 这种情况数据部门提供了一条几何线的同时，也提供了这条线终止里程和开始里程。这里就会存在一个问题，数据部门提供了里程数据的误差是多少。这就好比要将一米赋给一条90CM的绳子，在绳子上的计算结果肯定是有误差的，而这个误差大小由开始里程与终止里程以及长度三个决定的，这个误差就不可控了。在这种情况，误差还会被总长度给平均掉，不会造成误差的叠加，还是能够接受的。 with test_table as (select geom as line, ST_LineInterpolatePoint(geom,0.1) as point, st_length(geom::geography) as length,ST_LineInterpolatePoint(geom,0) as point0 ,ST_LineInterpolatePoint(geom,1) as point1 from test_line) select ST_InterpolatePoint(ST_AddMeasure(line,1000,length+200+1000),point),length/10,point from test_table ------------ 18485.740134863605 | 17465.740134864067 4、纯业务 这种情况数据部门提供的是一条带M值的线，如果这个M值的准确的话，完全按照M值去计算还是符合业务的。但是我就遇到过这样的情况，对方提供的数据本身自带错误（误差几千米）。这就好比将1米赋给一个60里面的绳子，糟糕的是还要一直去纠结误差问题。而程序是基于数据是准确的（误差也在可接受范围），最终的计算结果差了很多也是可以能理解的。但是这个数据问题又是比较难找的，需要跨部门一个一个找过去。 with test_table as (select geom as line, ST_LineInterpolatePoint(geom,0.1) as point, st_length(geom::geography) as length,ST_LineInterpolatePoint(geom,0) as point0 ,ST_LineInterpolatePoint(geom,1) as point1 from test_line) select ST_InterpolatePoint(line,point),length/10,point from test_table --------- 39565.59199126357 | 17465.740134864067 总结 在上面的四个场景中，第四个场景是我真实碰见过的一个场景，而其他三个场景则是我为了找出问题所在做的几个实验。在做实验过程中，我还一度认为这是postgis的bug。还好最终定位出了问题，发现不是程序问题。但是把发现的问题抛出后，别的部门又是不认的。至于里面造成的原因，可能是坐标系弄错了，也有可能是软件操作错误。这里还把多个小段合并成长线的工作量给忽略掉了，所以真实的应用场景将会更加复杂。这就是为什么我们很少看到线性参考被真实的使用。我想碰到这样的情况，开发人员估计都会放弃这种数据结构，宁肯用更加繁琐操作。写这一小节的目的也是让使用线性参考的开发人员注意所带来的非技术问题，谨慎使用这个数据结构。 "}}