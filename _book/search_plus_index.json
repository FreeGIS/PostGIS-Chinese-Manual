{"./":{"url":"./","title":"Introduction","keywords":"","body":"PostGIS-Chinese-Manual PostGIS中文手册，富含大量实际案例和使用场景。 一 安装环境： 1.1 安装nodejs 1.2 全局安装gitbook npm install gitbook-cli -g 1.3 获取仓库并安装启动插件 git clone git@github.com:FreeGIS/PostGIS-Chinese-Manual.git cd PostGIS-Chinese-Manual gitbook install 1.4 启动项目 gitbook serve 页面预览地址：http://localhost:4000 "},"installation/PostgreSQL Installation.html":{"url":"installation/PostgreSQL Installation.html","title":"二 安装","keywords":"","body":"2.1 PostgreSQL安装 2.1.1 升级gcc 从镜像中下载较新的gcc压缩文件并解压： [root@ ~]# wget -c http://mirror.koddos.net/gcc/releases/gcc-9.2.0/gcc-9.2.0.tar.xz [root@ ~]# tar xvf gcc-9.2.0.tar.xz 下载并安装gcc依赖: [root@ ~]# cd gcc-9.2.0 [root@ gcc-9.2.0]# ./contrib/download_prerequisites 安装gcc，通过--prefix指定安装路径： [root@ gcc-9.2.0]# ./configure --prefix=/usr/local/gcc-9.2.0 --enable-checking=release --enable-languages=c,c++ --disable-multilib #服务器如果核数较多可以使用并行编译，比如有2核 # make -j 4 #-j后的并行数量应等于核数的2倍，不要太多。 [root@ gcc-9.2.0]# make -j 4 [root@ gcc-9.2.0]# make install 配置环境变量： [root@ gcc-9.2.0]# vi /etc/profile #将gcc加入path，注意path里有其他bin不要改，在后面追加，以免影响其他系统 export GCC_HOME=/usr/local/gcc-9.2.0 export PATH=$GDAL_HOME/bin:$GCC_HOME/bin:$PATH # :wq! 保存退出 #重启生效： [root@ gcc-9.2.0]# source /etc/profile 验证gcc安装： [root@ ~]# gcc --version gcc (GCC) 9.2.0 Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 移除低版本的yum安装的gcc，如果安装过将会卸载： [root@ ~]# yum remove gcc 更新系统库依赖，避免编译时发生glibcxx_x.x.xxx not found等lib包因版本差异导致的错误： #先全局查询libstdc++.so.6包所在位置 [root@ ~]# find / -name libstdc++.so.6 /usr/lib64/libstdc++.so.6 /usr/lib/libstdc++.so.6 /usr/local/gcc-9.2.0/lib64/libstdc++.so.6 #其中/usr/local是我们刚刚安装的，/lib与/lib64我们不清楚是不是残留，所以必须用新的直接替换即可。 [root@ ~]# cp /usr/local/gcc-9.2.0/lib64/libstdc++.so.6 /usr/lib [root@ ~]# cp /usr/local/gcc-9.2.0/lib64/libstdc++.so.6 /usr/lib64 2.1.2 其他依赖安装 [root@ ~]# yum install -y vim-enhanced.x86_64 gcc-java apr apr-devel openssl openssl-devel java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-devel.x86_64 perl-Module-Install.noarch readline-devel.x86_64 为了能在数据库中使用uuid，先要安装下uuid的库： # 下载uuid-1.6.2.tar.gz然后拷贝到安装服务器上。由于官方链接太烂，根本点不开，先暂时在百度网盘分享个资源： [uuid-1.6.2.tar.gz](https://pan.baidu.com/s/1NSHU8WrczfGDDsxYhEcAQQ) [root@ ~]# tar -zxvf uuid-1.6.2.tar.gz [root@ ~]# cd uuid-1.6.2 [root@ ~]# ./configure [root@ ~]# make [root@ ~]# make install 2.1.3 新建用户 [root@ ~]# useradd postgres 2.1.4 下载PG12源码编译安装 [root@ ~]# wget https://ftp.postgresql.org/pub/source/v12.1/postgresql-12.1.tar.gz [root@ ~]# tar -zxvf postgresql-12.1.tar.gz [root@ ~]# cd postgresql-12.1 [root@ postgresql-12.1]# ./configure --prefix=/home/postgres --enable-thread-safety --with-uuid=ossp --with-libs=/usr/local/lib --with-includes=/usr/local/include [root@ postgresql-12.1]# make -j 4 [root@ postgresql-12.1]# make install # 安装contrib工具包 [root@ postgresql-12.1]# cd contrib [root@ contrib]# make [root@ contrib]# make install 2.1.5 权限设置 #把程序安装目录全部赋权给postgres用户 [root@ contrib]# chown -R postgres.postgres /home/postgres/ 2.1.6 配置postgres用户环境变量 [root@ contrib]# su - postgres [postgres@ ~]$ vi .bashrc #编辑内容如下： PGHOME=/home/postgres export PGHOME PGDATA=$PGHOME/data export PGDATA PATH=$PATH:$HOME/.local/bin:$HOME/bin:$PGHOME/bin export PATH # wq! 保存退出 #重启生效 [postgres@ ~]$ source .bashrc 2.1.7 数据库初始化与启动 [postgres@ ~]$ initdb -D $PGDATA [postgres@ ~]$ pg_ctl start -D $PGDATA #登录数据库 [postgres@ ~]$ psql psql (12.1) Type \"help\" for help. postgres=# 到此为止，数据库已经完成安装，但只能本机连接，性能参数配置是默认的。有时候希望其他客户端也能连接，需要设置$PGDATA中的pg_hba.conf与postgresql.conf中相关参数，这些内容可以详细查看其他PG相关的博客和书籍。 "},"installation/PostGIS Installation.html":{"url":"installation/PostGIS Installation.html","title":"2.2 PostGIS安装","keywords":"","body":"2.2 PostGIS安装 本教程安装PostGIS 3.0,3.0依赖的库有geos,proj,gdal,libxml,json-c,protobuf，如何要支持三维需安装sfcgal，如果要做路网分析需安装pgrouting。 2.2.1 安装依赖 2.2.1.1 geos [root@ ~]# wget https://download.osgeo.org/geos/geos-3.8.0.tar.bz2 [root@ ~]# tar -jxvf geos-3.8.0.tar.bz2 [root@ ~]# cd geos-3.8.0 #指定目录安装 [root@ geos-3.8.0]# ./configure --prefix=/usr/local/geos-3.8.0 [root@ geos-3.8.0]# make -j 4 [root@ geos-3.8.0]# make install 2.2.1.2 proj [root@ ~]# wget http://download.osgeo.org/proj/proj-6.2.1.tar.gz [root@ ~]# tar -zxvf proj-6.2.1.tar.gz [root@ ~]# cd proj-6.2.1 #指定目录安装 [root@ proj-6.2.1]# ./configure --prefix=/usr/local/proj-6.2.1 [root@ proj-6.2.1]# make -j 4 [root@ proj-6.2.1]# make install 2.2.1.3 gdal [root@ ~]# wget https://download.osgeo.org/gdal/3.0.2/gdal-3.0.2.tar.gz [root@ ~]# tar -zxvf gdal-3.0.2.tar.gz [root@ ~]# cd gdal-3.0.2 #编译时间比较久，指定目录安装，且绑定已安装的pg [root@ gdal-3.0.2]# ./configure --prefix=/usr/local/gdal-3.0.2 --with-pg=/home/postgres/bin/pg_config [root@ gdal-3.0.2]# make -j 4 [root@ gdal-3.0.2]# make install 2.2.1.4 jsonc,libxml [root@ ~]# wget https://github.com/json-c/json-c/archive/json-c-0.13.1-20180305.tar.gz [root@ ~]# tar -zxvf json-c-0.13.1-20180305.tar.gz [root@ ~]# cd json-c-0.13.1-20180305 [root@ json-c-0.13.1-20180305]# ./configure --prefix=/usr/local/json-c-0.13.1 [root@ json-c-0.13.1-20180305]# make -j 4 [root@ json-c-0.13.1-20180305]# make install [root@ ~]# wget https://github.com/GNOME/libxml2/archive/v2.9.7.tar.gz [root@ ~]# tar -zxvf libxml2-sources-2.9.7.tar.gz [root@ ~]# cd libxml2-2.9.7 [root@ libxml2-2.9.7]# ./configure --prefix=/usr/local/libxml2-2.9.7 [root@ libxml2-2.9.7]# make -j 4 [root@ libxml2-2.9.7]# make install 2.2.1.5 protobuf,protobuf-c [root@ ~]# wget https://github.com/protocolbuffers/protobuf/archive/v3.10.1.tar.gz [root@ ~]# tar -zxvf protobuf-3.10.1.tar.gz [root@ ~]# cd protobuf-3.10.1 [root@ protobuf-3.10.1]# ./configure --prefix=/usr/local/protobuf-3.10.1 [root@ protobuf-3.10.1]# make -j 4 [root@ protobuf-3.10.1]# make install #配置环境变量，增加下protobuf-3.10.1/bin [root@ ~]# vi /etc/profile export PROTOBUF_HOME=/usr/local/protobuf-3.10.1 export PATH=$GCC_HOME/bin:$PROTOBUF_HOME/bin:$PATH #保存退出 [root@ ~]# source /etc/profile #验证protobuf执行程序 [root@ ~]# protoc --version libprotoc 3.10.1 #protobuf安装成功 [root@ ~]# wget https://github.com/protobuf-c/protobuf-c/releases/download/v1.3.2/protobuf-c-1.3.2.tar.gz [root@ ~]# tar -zxvf protobuf-c-1.3.2.tar.gz [root@ ~]# cd protobuf-c-1.3.2 #导入protobuf的pkgconfig，否则\"--No package 'protobuf' found\" [root@ protobuf-c-1.3.2]# export PKG_CONFIG_PATH=/usr/local/protobuf-3.10.1/lib/pkgconfig [root@ protobuf-c-1.3.2]# ./configure --prefix=/usr/local/protobuf-c-1.3.2 [root@ protobuf-c-1.3.2]# make -j 4 [root@ protobuf-c-1.3.2]# make install #配置环境变量，增加下protobuf-c-1.3.2/bin [root@ ~]# vi /etc/profile export PROTOBUF_HOME=/usr/local/protobuf-3.10.1 export PROTOBUFC_HOME=/usr/local/protobuf-c-1.3.2 export PATH=$GCC_HOME/bin:$PROTOBUF_HOME/bin:$PROTOBUFC_HOME/bin:$PATH #保存退出 [root@ ~]# source /etc/profile 2.2.1.6 sfcgal (三维场景，可选择安装) sfcgal需要cmkae编译，需先安装下cmake： [root@ ~]# wget https://github.com/Kitware/CMake/releases/download/v3.16.2/cmake-3.16.2.tar.gz [root@ ~]# tar -zxvf cmake-3.16.2.tar.gz [root@ ~]# cd cmake-3.16.2 [root@ cmake-3.16.2]# ./configure --prefix=/usr/local/cmake-3.16.2 [root@ cmake-3.16.2]# make -j 4 [root@ cmake-3.16.2]# make install #配置环境变量 [root@ ~]# vi /etc/profile export CMAKE_HOME=cmake-3.16.2 export PATH=$GCC_HOME/bin:$CMAKE_HOME/bin:$PROTOBUF_HOME/bin:$PROTOBUFC_HOME/bin:$PATH #保存退出 [root@ ~]# source /etc/profile sfcgal依赖boost,cgal，需要提前编译，编译默认目录，避免编译sfcgal时各种找不到库的问题。 [root@ ~]# yum install boost-devel [root@ ~]# wget https://github.com/CGAL/cgal/archive/releases/CGAL-4.13.tar.gz [root@ ~]# tar -zxvf CGAL-4.13.tar.gz [root@ ~]# cd CGAL-4.13 [root@ CGAL-4.13]# mkdir build && cd build #cmake不要指定安装路径 [root@ build]# cmake .. [root@ build]# make [root@ build]# make install 编译安装sfcgal： [root@ ~]# wget https://github.com/Oslandia/SFCGAL/archive/v1.3.7.tar.gz [root@ ~]# tar -zxvf v1.3.7.tar.gz [root@ ~]# cd SFCGAL-1.3.7 [root@ SFCGAL-1.3.7]# mkdir build & cd build [root@ build]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/sfcgal-1.3.7 .. [root@ build]# make -j 4 [root@ build]# make install pgrouting可以单独安装，在之后章目里会单独介绍。 2.2.2 PostGIS安装 2.2.2.1 配置ld.so.conf [root@ ~]# vim /etc/ld.so.conf #编辑内容如下 include ld.so.conf.d/*.conf /home/postgres/lib /usr/local/proj-6.2.1/lib /usr/local/gdal-3.0.2/lib /usr/local/geos-3.8.0/lib /usr/local//sfcgal-1.3.7/lib64 /usr/local/json-c-0.13.1/lib /usr/local/libxml2-2.9.7/lib /usr/local/protobuf-3.10.1/lib /usr/local/protobuf-c-1.3.2/lib #编辑完成后wq!保存退出 #保存配置，重启生效 [root@ ~]# ldconfig -v 2.2.2.2 安装postgis [root@ ~]# wget http://download.osgeo.org/postgis/source/postgis-3.0.0.tar.gz [root@ ~]# tar -zxvf postgis-3.0.0.tar.gz [root@ ~]# cd postgis-3.0.0 #根据安装不同的要求，选择任意一个configure #基本安装，不带sfcgal [root@ postgis-3.0.0]# ./configure --prefix=/home/postgres --with-gdalconfig=/usr/local/gdal-3.0.2/bin/gdal-config --with-pgconfig=/home/postgres/bin/pg_config --with-geosconfig=/usr/local/geos-3.8.0/bin/geos-config --with-projdir=/usr/local/proj-6.2.1 --with-xml2config=/usr/local/libxml2-2.9.7/bin/xml2-config --with-jsondir=/usr/local/json-c-0.13.1 --with-protobufdir=/usr/local/protobuf-c-1.3.2 # 带protobuf,sfcgal安装 [root@ postgis-3.0.0]# ./configure --prefix=/home/postgres --with-gdalconfig=/usr/local/gdal-3.0.2/bin/gdal-config --with-pgconfig=/home/postgres/bin/pg_config --with-geosconfig=/usr/local/geos-3.8.0/bin/geos-config --with-projdir=/usr/local/proj-6.2.1 --with-xml2config=/usr/local/libxml2-2.9.7/bin/xml2-config --with-jsondir=/usr/local/json-c-0.13.1 --with-protobufdir=/usr/local/protobuf-c-1.3.2 --with-sfcgal=/usr/local/sfcgal-1.3.7/bin/sfcgal-config [root@ postgis-3.0.0]# make -j 4 [root@ postgis-3.0.0]# make install 可能报错什么can not found lsqlite3等错误： yum instlal sqlite-devel 2.2.2.3 验证安装 [root@ ~]# su - postgres [postgres@ ~]$ psql psql (12.1) Type \"help\" for help. postgres=# create database mytest; CREATE DATABASE postgres=# \\c mytest You are now connected to database \"mytest\" as user \"postgres\". #验证postgis扩展 mytest=# create extension postgis; CREATE EXTENSION #验证栅格类数据需要的raster扩展 mytest=# create extension postgis_raster; CREATE EXTENSION #如果安装带有sfcgal，验证下三维sfcgal扩展 mytest=# create extension postgis_sfcgal; CREATE EXTENSION "},"vector_function/Accessors.html":{"url":"vector_function/Accessors.html","title":"八 矢量函数","keywords":"","body":"8.4 元数据读写 以下函数返回图形类型和图形类型对应的坐标和拓扑维度。 GeometryType 作用：返回图形类型字符串，字符串形式是：'POINT','LINESTRING','POLYGON','MULTIPOINT','MULTILINESTRING','MULTIPOLYGON'等等。 SELECT GeometryType(ST_GeomFromText('Point(118 32)')); geometrytype ------------------- POINT SELECT GeometryType(ST_GeomFromText('LineString(118 32,119 33)')); geometrytype ------------------- LINESTRING ST_GeometryType 作用：返回图形类型SQL_MM字符串，字符串形式是：'ST_Point','ST_Linestring','ST_Polygon','ST_MultiPoint','ST_MultiLinestring','ST_MultiPolygon'等等。 SELECT ST_GeometryType(ST_GeomFromText('Point(118 32)')); st_geometrytype ------------------- ST_Point SELECT ST_GeometryType(ST_GeomFromText('LineString(118 32,119 33)')); st_geometrytype ------------------- ST_Linestring ST_CoordDim/ST_NDims 作用：两个函数一模一样，都是返回图形坐标维度，如二维返回2，xyz,xym都返回3，xyzm返回4。 坐标形式 维度 xy 2 xyz 3 xym 3 xyzm 4 --xy SELECT ST_CoordDim(ST_GeomFromText('Point(1 2)')); st_coorddim ------------- 2 --xyz SELECT ST_CoordDim(ST_GeomFromText('PointZ(1 2 3')); st_coorddim ------------- 3 --xym SELECT ST_CoordDim(ST_GeomFromText('PointM(1 2 3')); st_coorddim ------------- 3 --xyzm SELECT ST_CoordDim(ST_GeomFromText('PointZM(1 2 2 2')); st_coorddim ------------- 4 ST_Dimension 作用：返回图形的拓扑维度，拓扑维度只区分大类，如POINT形式，子形式包括MULTIPOINT,POINTZ,POINTM,POINTZM，统统都返回0，以此类推。 几何拓扑形式 | 维度 ---|--- POINT | 0 LINESTRING | 1 POLYGON | 2 EMPTY | -1 --xy点 SELECT ST_CoordDim(ST_GeomFromText('Point(1 2)')); ST_Dimension ------------- 0 --multi点 SELECT ST_CoordDim(ST_GeomFromText('MultiPoint(1 2,3 4)')); ST_Dimension ------------- 0 --xyz点 SELECT ST_CoordDim(ST_GeomFromText('PointZ(1 2 3')); ST_Dimension ------------- 0 --xym点 SELECT ST_CoordDim(ST_GeomFromText('PointM(1 2 3')); ST_Dimension ------------- 0 --xyzm点 SELECT ST_CoordDim(ST_GeomFromText('PointZM(1 2 2 2')); ST_Dimension ------------- 0 --linestring SELECT ST_CoordDim(ST_GeomFromText('LineString(1 2,3 4)')); ST_Dimension ------------- 1 --polygon SELECT ST_CoordDim(ST_GeomFromText('Polygon((0 0,0 1,1 1,1 0,0 0))')); ST_Dimension ------------- 2 对于类型不明确的，如GEOMETRYCOLLECTION，会选择集合里维度最高的子图形，将该子图形的图形拓扑维度返回： SELECT ST_Dimension('GEOMETRYCOLLECTION(LINESTRING(1 1,0 0),POINT(0 0))'); ST_Dimension ----------- 1 SELECT ST_Dimension('GEOMETRYCOLLECTION(Polygon((0 0,0 1,1 1,1 0,0 0)),LINESTRING(1 1,0 0),POINT(0 0))'); ST_Dimension ----------- 2 ST_Zmflag 作用：该函数主要用于测试一个图形的坐标究竟是带m还是带z值，根据其不同转态返回能提现zm状态的维度编码。 zm坐标形式 | 维度 ---|--- xy | 0 xym | 1 xyz | 2 xyzm | 3 ST_Zmflag与ST_CoordDim,ST_NDims不同，ST_CoordDim,ST_NDims中，xyz与xym都返回3，xyzm返回4，这两个函数返回值只是表达了图形坐标是几维构成，但是同样是三维，究竟是xyz还是xym是区分不了的。而通过ST_Zmflag函数，能得到准确的图形坐标究竟是xyz还是xym形式。 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRING(1 2, 3 4)')); st_zmflag ----------- 0 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGM(1 2 0, 3 4 0)')); st_zmflag ----------- 1 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGZ(1 2 0, 3 4 0)')); st_zmflag ----------- 2 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGZM(1 2 0 0, 3 4 0 0)')); st_zmflag ----------- 3 --对比下ST_CoordDim,ST_NDims SELECT ST_CoordDim(ST_GeomFromEWKT('LINESTRINGZ(1 2 0, 3 4 0)')); ST_CoordDim ----------- 3 SELECT ST_CoordDim(ST_GeomFromEWKT('LINESTRINGM(1 2 0, 3 4 0)')); ST_CoordDim ----------- 3 --ST_CoordDim,ST_NDims无法区分第三维究竟是z还是m。 以下函数为测试函数，判别geometry某个属性是否具备某个状态。 ST_HasArc 作用：该函数主要用于测试一个图形是否包含圆弧。判断依据比较勉强，仅仅判断图形或者图形集合中的子图形是不是包含圆弧标志的字符串。 下例以CIRCULARSTRING(1 1, 2 2, 3 3, 4 4, 5 5)说明，这个圆弧长什么样都不知道，但是只要用CIRCULARSTRING声明其是圆弧，就会返回true。圆弧在PostGIS中其实能构造但是其他可视化软件不认识，无法可视化。该函数使用频率其实也非常低。 SELECT ST_HasArc(ST_GeomFromEWKT('CIRCULARSTRING(1 1, 2 2, 3 3, 4 4, 5 5)')); st_hasarc -------- true ST_IsPolygonCCW 作用：测试多边形是否具有逆时针方向的外环和顺时针方向的内环。 --外环是逆时针方向，内环是顺时针方向 select ST_IsPolygonCCW(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))')); ST_IsPolygonCCW ------------------- true --外环是逆时针方向，内环也是逆时针方向 select ST_IsPolygonCCW(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,2 1,2 2,1 2,1 1))')); ST_IsPolygonCCW ------------------- false ST_IsPolygonCW 作用：测试多边形是否具有顺时针方向的外环和逆时针方向的内环。 select ST_IsPolygonCW(ST_GeomFromEWKT('Polygon((0 0,0 3,3 3,3 0,0 0),(1 1,2 1,2 2,1 2,1 1))')); ST_IsPolygonCW ------------------- true ST_IsClosed 作用：判别一个线是否闭合。Polygon一定是闭合的否则构造会出错，因此，该函数常用就是判别线。所谓闭合，就是起点=终点 ，即首尾相连。 主要使用场景： SELECT ST_IsClosed(ST_GeomFromEWKT('LINESTRING(0 0, 1 1)')); st_isclosed ------------- false SELECT ST_IsClosed(ST_GeomFromEWKT('LINESTRING(0 0, 1 1,1 0,0 0)')); st_isclosed ------------- true 以下场景不常用，但是该函数也支持，并且返回结果有点差异。 多义线，每个子线都是首尾相连的： SELECT ST_IsClosed(ST_GeomFromEWKT('MULTILINESTRING((0 0, 1 1,1 0,0 0),(3 3,4 4,4 3,3 3))')); st_isclosed ------------- true 多义线，至少有个子线不是首尾相连的： SELECT ST_IsClosed(ST_GeomFromEWKT('MULTILINESTRING((0 0, 1 1,1 0,0 0),(3 3,4 4,4 3,3.5 3))')); st_isclosed ------------- true 结论：多义线实际是计算每个子线是否闭合，只有所有子线都闭合，才返回true，任意一个子线不闭合，就会返回false。 根据闭合的概念 起点=终点 那么对于点而言，起点终点就是一个点，所以一定返回true；而多义点和多义线一样，是分别计算每个子图形是否闭合，由于MultiPoint的子图形都是Point，而Point一定返回true，那么意味着于MultiPoint的子图形都是闭合的。 SELECT ST_IsClosed('POINT(0 0)'::geometry); st_isclosed ------------- true SELECT ST_IsClosed('MULTIPOINT((0 0), (1 1))'::geometry); st_isclosed ------------- true 结论： 1 对于点，多义点，该函数总是返回true。 2 对于线首尾相连认定闭合，多义线要保证每个子线都是闭合才认为多义线闭合。 3 对于面，多义面，由于面一定是闭合的，因此该函数总是返回true。 4 该函数其实仅仅用于判定LineString是否闭合为主要目的。 ST_IsCollection 作用：判定一个图形是否是集合类型，集合类型列表如下： • GEOMETRYCOLLECTION • MULTI{POINT,POLYGON,LINESTRING,CURVE,SURFACE} • COMPOUNDCURVE 当图形类型为列表类型时，该函数返回true，否则返回false。 --单线 SELECT ST_IsCollection('LINESTRING(0 0, 1 1)'::geometry); st_iscollection ------------- false --多义线 SELECT ST_IsCollection('MultiLINESTRING((0 0, 1 1))'::geometry); st_iscollection ------------- true ST_IsEmpty 作用：判定一个图形是否为空。 SELECT ST_IsEmpty(ST_GeomFromText('POLYGON EMPTY')); st_isempty ------------ true SELECT ST_IsEmpty(ST_GeomFromText('POLYGON((1 2, 3 4, 5 6, 1 2))')); st_isempty ------------ false ST_IsRing 作用：判定是否为“环”，图形中的换“环”其实是闭合的单线，比如Polygon就是一个个环组成的图形。对于“环”的定义应满足如下两点： 1 闭合的线，则ST_IsClosed(geom)=true。 2 该线不自相交，不自相切，则ST_IsSimple(geom)=true。 ​ SELECT ST_IsRing(geom), ST_IsClosed(geom), ST_IsSimple(geom) FROM (SELECT 'LINESTRING(0 0, 0 1, 1 1, 1 0, 0 0)'::geometry AS geom) AS foo; st_isring | st_isclosed | st_issimple -----------+-------------+------------- true | true | true SELECT ST_IsRing(geom), ST_IsClosed(geom), ST_IsSimple(geom) FROM (SELECT 'LINESTRING(0 0, 0 1, 1 0, 1 1, 0 0)'::geometry AS geom) AS foo; st_isring | st_isclosed | st_issimple -----------+-------------+------------- false | true | false 结论：由“环”定义可知，只有当则ST_IsClosed与则ST_IsSimple两个函数都返回true，ST_IsRing(geom)才会返回true。 ST_IsSimple 作用：判定一个图形是否自相交或者自相切。 示意图见ST_IsRing中示意图。 SELECT ST_IsSimple('LINESTRING(0 0, 0 1, 1 1, 1 0, 0 0)'::geometry); st_issimple ------------- true SELECT ST_IsSimple('LINESTRING(0 0, 0 1, 1 0, 1 1, 0 0)'::geometry); st_issimple ------------- false 以上函数为测试函数，判别geometry某个属性是否具备某个状态。 ST_Boundary 作用：返回图形边界，抽象，用例子说明。 1 对于点而言，图形边界都是empty： SELECT ST_AsText(ST_Boundary('Point(1 1)'::geometry)); st_astext ------------------------ GEOMETRYCOLLECTION EMPTY SELECT ST_AsText(ST_Boundary('MultiPoint(1 1,2 2)'::geometry)); st_astext ------------------------- GEOMETRYCOLLECTION EMPTY 2 对于未闭合线而言，图形边界是其起点和终点： SELECT ST_AsText(ST_Boundary('LINESTRING(1 1,2 2,3 -1)'::geometry)); st_astext ------------------------- MULTIPOINT(1 1,3 -1) SELECT ST_AsText(ST_Boundary('MultiLINESTRING((1 1,2 2,3 -1),(0 0,-1 -1,-2 3))'::geometry)); st_astext ------------------------------ MULTIPOINT(1 1,3 -1,0 0,-2 3) 补充：对MultiLINESTRING而言，分别计算子线的边界（起点，终点），然后把所有子线的边界（都是点）塞到一个MULTIPOINT返回。 3 对于闭合线，图形边界为空： SELECT ST_AsText(ST_Boundary('LINESTRING(1 1,2 2,3 -1,1 1)'::geometry)); st_astext ------------------------ MULTIPOINT EMPTY 4 对于面而言，图形边界是其环： 单义面： select ST_AsText(ST_Boundary(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))'))); st_astext ------------------------------------------------------------ MULTILINESTRING((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)) 多义面： select ST_AsText(ST_Boundary( ST_GeomFromEWKT('MultiPolygon(((0 0,1 0,1 1,0 1,0 0)),((2 2,2 3,3 3,3 2,2 2)))'))); st_astext ------------------------------------------------------------ MULTILINESTRING((0 0,1 0,1 1,0 1,0 0),(2 2,2 3,3 3,3 2,2 2)) ST_Envelope 作用：返回一个图形的外接矩形。点的外接矩形是Point，线面的外接矩形是个长方形Polygon，xyz的线面外接矩形仍然是xy维度里的长方形，而非官方手册说的长方体。 --点 SELECT ST_AsText(ST_Envelope('POINT(1 3)'::geometry)); st_astext ------------ POINT(1 3) --线 SELECT ST_AsText(ST_Envelope('LineString(0 0,1 1)'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) --面 SELECT ST_AsText(ST_Envelope('Polygon((0 0,1 0,1 1,0 1,0 0))'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) --xyz 线 SELECT ST_AsText(ST_Envelope('LineStringZ(0 0 0,1 1 1)'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) --xyz面 SELECT ST_AsText(ST_Envelope('PolygonZ((0 0 0,1 0 1,1 1 1,0 1 0,0 0 0))'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) 说明：xyz的线面返回还是二维的xy面，z轴被丢失了。 ST_Envelope与Box2D 相同点：ST_Envelope与Box2D都是获取输入图形的外接矩形。 不同点：ST_Envelope返回的是个geometry对象，如'Polygon((minx miny,minx maxy,maxx maxy,maxx miny,minx miny))::geometry'；Box2D返回的是box2d对象，如BOX(minx,miny,maxx,maxy)。 ST_BoundingDiagonal 作用：返回一个图形边界框构成的对角线。该函数会保留所有的srid和zm维度。 函数定义：ST_BoundingDiagonal(geometry geom, boolean fits=false) 参数说明：fits参数表示是否采用最佳拟合，在输入图形节点很多的情况下，fits=true则获取的边界框构成的对角线更精确点，但是稍慢；fits=false则获取的边界框范围稍大，但是速度更快。fits无论true或false，对角线构成的边界框都会覆盖输入图形（对角线的bbox>=输入图形的bbox） --xy SELECT ST_AsText(ST_BoundingDiagonal('Polygon((0 0,1 0,1 1,0 1,0 0))'::geometry)); st_astext --------------------------- LINESTRING(0 0,1 1) --xyz SELECT ST_AsText(ST_BoundingDiagonal('PolygonZ((0 0 0,1 0 1,1 1 1,0 1 0,0 0 0))'::geometry)); st_astext --------------------------- LINESTRING Z (0 0 0,1 1 1) ST_X,ST_Y,ST_Z,ST_M 作用：ST_X,ST_Y,ST_Z,ST_M四个函数分别返回Point的x，y，z，m值，入参必须是Point。 SELECT ST_X(geom), ST_Y(geom), ST_Z(geom),ST_M(geom) FROM (SELECT ST_GeomFromEWKT('POINT(1 2 3 4)') AS geom) AS foo; st_x | st_y | st_z | st_m -------------------------- 1 | 2 | 3 | 4 ST_StartPoint,ST_EndPoint 作用：ST_StartPoint,ST_EndPoint分别返回LineString或CircularLineString的起点，终点，入参必须是LineString与CircularLineString，如果是其他图形类型，返回null。 SELECT ST_AsText(ST_StartPoint(geom)) startpt, ST_AsText(ST_EndPoint(geom)) endpt FROM (SELECT ST_GeomFromEWKT('LINESTRING(0 0, 0 1, 1 0, 1 1)') AS geom) AS foo; startpt | endpt -------------------------- POINT(0 0) | POINT(1 1) SELECT ST_EndPoint('POINT(1 1)'::geometry) IS NULL AS is_null; is_null -------- true ST_NumGeometries,ST_GeometryN 作用：ST_NumGeometries返回一个图形集合中子图形的数量，ST_GeometryN返回图形集合中序号为n的子图形。两者关系类似与其他语言中获取数组的长度，根据索引返回数组中指定子项。 图形集合的概念：GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON, POLYHEDRALSURFACE。 索引序号：数据库中数组首项序号是1。与其他语言中数组首项序号为0有区别。 --获取图形集合中的子图形数量。 SELECT ST_NumGeometries(ST_GeomFromEWKT('GEOMETRYCOLLECTION( POINT(0 0), LINESTRING(0 0,1 1), POLYGON((0 0,1 0,1 1,0 1,0 0)))')); ST_NumGeometries --------------------------- 3 --获取图形集合中序号为2的子图形 SELECT ST_AsText(ST_GeometryN(ST_GeomFromEWKT('GEOMETRYCOLLECTION( POINT(0 0), LINESTRING(0 0,1 1), POLYGON((0 0,1 0,1 1,0 1,0 0)))'),2)); ST_GeometryN --------------------------- LINESTRING(0 0,1 1) --Multi类型 SELECT ST_NumGeometries(ST_GeomFromEWKT('MultiPOINT(0 0,1 1,2 2)')); ST_NumGeometries --------------------------- 3 SELECT ST_AsText(ST_GeometryN(ST_GeomFromEWKT('MultiPOINT(0 0,1 1,2 2)'),2)); ST_GeometryN --------------------------- POINT(1 1) ST_NRings,ST_ExteriorRing,ST_NumInteriorRings,ST_NumInteriorRing,ST_InteriorRingN 函数名称 作用 ST_NRings 返回Polygon的“环”数量，包括外环和内环 ST_NumInteriorRings 返回Polygon的“内环”数量 ST_NumInteriorRing 与ST_NumInteriorRings一模一样 ST_ExteriorRing 获取Polygon的外环(Polygon只有一个外环) ST_InteriorRingN 获取Polygon的指定序号的内环(Polygon可以有多个内环) 所谓“内环”就是面内组成孔洞的闭合线（孔洞边界线）。 限制说明：不用多想，只要记住这些函数仅支持Polygon类型。 --无孔洞 --该面就只有1个外环，内环数量0 SELECT ST_NRings(geom),ST_NumInteriorRings(geom) from (SELECT ST_GeomFromEWKT('Polygon((0 0,1 0,1 1,0 1,0 0))') AS geom) AS foo; ST_NRings | ST_NumInteriorRings -------------------------------------- 1 | 0 --有孔洞 --返回孔洞数量 SELECT ST_NRings(geom),ST_NumInteriorRings(geom) from (SELECT ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))') AS geom) AS foo; ST_NRings | ST_NumInteriorRings -------------------------------------- 2 | 1 --获取外环的图形 SELECT ST_AsText(ST_ExteriorRing(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))'))); ST_AsText ------------------------------- LINESTRING(0 0,3 0,3 3,0 3,0 0) --获取第一个孔洞的图形 SELECT ST_AsText(ST_InteriorRingN(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))'),1)); ST_AsText ------------------------------- LINESTRING(1 1,1 2,2 2,2 1,1 1) ST_NRings是支持MultiPolygon的： SELECT ST_NRings(ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)))')); ST_NRings ------------ 2 PostGIS官网说ST_NumInteriorRings支持MultiPolygon，返回MultiPolygon的第一个Polygon中的内环数量，但实测发现官网是错误的，ST_NumInteriorRings对MultiPolygon返回了null： SELECT ST_NumInteriorRings(ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)))')); ST_NumInteriorRings -------------------- null 结论：除ST_NRings支持MultiPolygon外，原则上这些函数都认为是只处理Polygon类型比较好，实际也的确只是用来处理Polygon的。 ST_NumPatches,ST_PatchN 函数名称 作用 ST_NumPatches 返回多面曲面上面的数量，对非多面曲面类型返回null ST_PatchN 返回多面曲面上指定序号为n的曲面，使用ST_GeometryN可以替代ST_PatchN，结果一样且查询更快 --返回曲面多面上面的数量 SELECT ST_NumPatches(ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )')); ST_NumPatches ------------ 6 --返回曲面多面上指定序号为n的曲面 SELECT ST_AsEWKT(ST_PatchN(geom, 2)) FROM (VALUES (ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )' )) ) As foo(geom); ST_AsEWKT ----------------------------------------- POLYGON((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0)) --其实使用ST_GeometryN可以替代ST_PatchN，结果一样。 ST_NPoints,ST_NumPoints,ST_PointN,ST_Points 函数名称 作用 ST_NPoints 返回geometry上Point点数量，不仅仅针对LineString。 ST_NumPoints 返回LineString或CircularString上节点数量，不支持Multi类型。 ST_PointN 返回LineString或CircularString指定序号为n的点，n=-1是终点。 ST_Points 返回geometry上所有Point点坐标，结果为MultiPoint形式。 --ST_NPoints SELECT ST_NPoints(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)')); ST_NPoints -------------- 3 SELECT ST_NPoints(ST_GeomFromText('Polygon((1 1,1 2,2 2,2 1,1 1))')); ST_NPoints -------------- 5 --ST_NumPoints SELECT ST_NumPoints(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)')); ST_NumPoints -------------- 3 SELECT ST_NumPoints(ST_GeomFromText('Polygon((1 1,1 2,2 2,2 1,1 1))')); ST_NumPoints -------------- null --序号为2 SELECT ST_AsText(ST_PointN(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'),2)); ST_AsText -------------- POINT(2 2) --序号为0 SELECT ST_AsText(ST_PointN(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'),0)); ST_AsText -------------- null --序号为-1 SELECT ST_AsText(ST_PointN(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'),-1)); ST_AsText -------------- POINT(3 4) --ST_Points select ST_AsText(ST_Points(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'))); ST_AsText ----------------------- MULTIPOINT(1 1,2 2,3 4) select ST_AsText(ST_Points(ST_GeomFromText('Polygon((1 1,1 2,2 2,2 1,1 1))'))); ST_AsText ------------------------------- MULTIPOINT(1 1,1 2,2 2,2 1,1 1) 结论：ST_NPoints和ST_NumPoints相同点是都获取图形的Point点数量；不同点是ST_NumPoints仅仅针对LineString或CircularString，而ST_NPoints还支持更多其他类型的图形。 ST_MemSize 作用：返回一个geom占用内存空间大小。 说明：ST_MemSize是PostgreSQL原生的pg_column_size, pg_size_pretty, pg_relation_size, pg_total_relatio_size等获取表或字段物理大小字段的补充，原因是原生函数不能准确表达geom的大小。 为什么不使用原生的pg函数去获取geometry或geom列或空间表的物理大小？由于geometry是个大对象，PG中对于大对象的物理存储提供了TOAST功能，只有了解TOAST的四种存储策略，才能理解为什么原生函数不适合，而要引入ST_MemSize，关于TOAS与PostGIS更多知识，请查看：待补充。 --单位是bytes，如果对象特别大，可以用pg_size_pretty函数显示的更人性化 --pg_size_pretty可以根据实际大小返回MB，GB等单位。 select ST_MemSize(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)')); ST_MemSize ---------- 80 ST_Summary 作用：以一个标准化的字符串描述一个图形的概要信息。 关键字： M: 图形坐标含有M值 Z: 图形坐标含有Z值 B: 有缓存bbox G: 图形为大地坐标 (geography) S: 图形有空间坐标系 SELECT ST_Summary(ST_GeomFromText('LINESTRING(0 0, 1 1)')) as geom1, ST_Summary(ST_GeomFromText('LINESTRINGM(0 0 0, 1 1 1)')) as geom2; geom1 | geom2 -------------------------------------------------------- LineString[] with 2 points | LineString[M] with 2 points select ST_Summary(ST_GeomFromText('LINESTRINGZ(0 0 0, 1 1 1)')) as geom3,ST_Summary(ST_GeomFromText('LINESTRING(0 0, 1 1)',4326)) as geom4; geom3 | geom4 -------------------------------------------------------- LineString[Z] with 2 points | LineString[S] with 2 points select ST_Summary(ST_GeogFromText('POLYGON((0 0, 1 1, 1 2, 1 1, 0 0))')) geog; geog -------------------------------- Polygon[BGS] with 1 ring: ring 0 has 5 points 注意：pg中数组都是从1开始计数的，在ST_InteriorRingN中n=1就是第一个外环。但是在ST_Summary返回的文本串里，第一个ring序号从0开始。 ST_Dump,ST_DumpPoints,ST_DumpRings 这三个函数返回值都是geometry_dump类型（缺少类型描述）的数据集。 函数名称 | 作用 ---|--- ST_Dump | 分解复杂组合图形 ST_DumpRings | 将Polygon分解成若干ring（环） ST_DumpPoints | 将图形分解成点 ST_Dump示例： --拆分集合 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_Dump(p_geom)) AS infos FROM ( SELECT ST_GeomFromEWKT('GEOMETRYCOLLECTION(LineString(0 0, 1 1, 1 0),LineString(1 0, 0 1))') AS p_geom) AS b) as a; path | geom ----------------------------------- {1} | LINESTRING(0 0,1 1,1 0) {2} | LINESTRING(1 0,0 1) --拆分多义线 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_Dump(p_geom)) AS infos FROM ( SELECT ST_GeomFromEWKT('MultiLineString((0 0, 1 1, 1 0),(1 0, 0 1))') AS p_geom) AS b) as a; path | geom -------------------------------- {1} | LINESTRING(0 0,1 1,1 0) {2} | LINESTRING(1 0,0 1) --拆分多义面 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_Dump(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0)),((1 1,1 2,2 2,2 1,1 1)))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1} | POLYGON((0 0,3 0,3 3,0 3,0 0)) {2} | POLYGON((1 1,1 2,2 2,2 1,1 1)) ST_DumpRings示例： select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_DumpRings(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1} | POLYGON((0 0,3 0,3 3,0 3,0 0)) {2} | POLYGON((1 1,1 2,2 2,2 1,1 1)) ST_DumpPoints分解成点的时候，path数组比较特殊，例如MultiPolygon拆分点后，path格式是{polygon_idx,ring_idx,pt_idx}，分别表达目前这个点在多义面中是哪个子面哪个子环哪个子节点上；而Polygon的path格式是{ring_idx,pt_idx},描述该点在面中位于哪个子环的哪个子节点；MultiLineString的path格式是{line_idx,pt_idx}，描述该点在多义线中位于哪个子线的哪个子节点；LineString的path格式就是{pt_idx}，很好理解。综述：path是描述这个点在图形中的层级关系的。 --多义面 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_DumpPoints(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1,1,1} | POINT(0 0) {1,1,2} | POINT(3 0) {1,1,3} | POINT(3 3) {1,1,4} | POINT(0 3) {1,1,5} | POINT(0 0) {1,2,1} | POINT(1 1) {1,2,2} | POINT(1 2) {1,2,3} | POINT(2 2) {1,2,4} | POINT(2 1) {1,2,5} | POINT(1 1) --单面 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_DumpPoints(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1,1} | POINT(0 0) {1,2} | POINT(3 0) {1,3} | POINT(3 3) {1,4} | POINT(0 3) {1,5} | POINT(0 0) {2,1} | POINT(1 1) {2,2} | POINT(1 2) {2,3} | POINT(2 2) {2,4} | POINT(2 1) {2,5} | POINT(1 1) "},"vector_function/AffineTransformations/ST_Affine.html":{"url":"vector_function/AffineTransformations/ST_Affine.html","title":"8.14 仿射变换","keywords":"","body":"ST_Affine 方法功能描述 通过该函数将一个图形进行仿射变换，转换成另一个图形，通常用于坐标系转换的场景。例如已知一批EPSG:4326坐标系的图形，需要叠加到一个自定义的底图上，该底图所有地物都是基于EPSG:4326坐标系旋转平移的，如果需要把数据正确叠加上去，需要对自己的数据也进行旋转平移后才能叠加，使用该函数可以实现这样的需求。 函数定义 二维： geometry ST_Affine(geometry geomA, float a, float b, float d, float e, float xoff, float yoff); 代表转换矩阵： / a b 0 xoff \\ / a b xoff \\ | d e 0 yoff | 公式简化为=> | d e yoff | | 0 0 1 0 | \\ 0 0 1 / \\ 0 0 0 1 / 顶点转换公式： x' = a*x + b*y + xoff y' = d*x + e*y + yoff z' = z 对于二维转换来说，z是不存在或者存在不做任何处理的，所以z' = z. 注意：xoff，yoff代表xy轴的平移量，而abde参数反映了二维图形的旋转缩放等变化。 三维： geometry ST_Affine(geometry geomA, float a, float b, float c, float d, float e, float f, float g, float h, float i, float xoff, float yoff, float zoff); 代表转换矩阵： / a b c xoff \\ | d e f yoff | | g h i zoff | \\ 0 0 0 1 / 顶点转换公式： x' = a*x + b*y + c*z + xoff y' = d*x + e*y + f*z + yoff z' = g*x + h*y + i*z + zoff 注意：xoff，yoff，zoff代表xyz轴的平移量，而abcdefghi参数反映了三维图形的旋转缩放等变化。 应用示例 说明：该函数能大量操作三维图形，但是因作图不是很方便，作者仅仅会添加二维示意图。 平移 将输入二维线向x,y轴分别平移1,0.5，平移矩阵参数： / 1 0 1 \\ | 0 1 0.5 | \\ 0 0 1 / 则套入二维的仿射变换函数：ST_Affine(geometry geomA, float a, float b, float d, float e, float xoff, float yoff)，那么a=1,b=0,xoff=1,d=0,e=1,yoff=0.5。 二维： select st_astext(geom) geom1,st_astext(ST_Affine(geom, 1, 0, 0, 1, 1, 0.5)) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(118 32, 119 33)') As geom) as foo; geom1 | geom2 --------------------------------------------------------- LINESTRING(118 32,119 33) | LINESTRING(119 32.5,120 33.5) 使用二维的ST_Affine，等同于对三维的z不处理，如下： select st_astext(geom) geom1,st_astext(ST_Affine(geom, 1, 0, 0, 1, 1, 0.5)) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(118 32 10, 119 33 20)') As geom) as foo; geom1 | geom2 --------------------------------------------------------- LINESTRING(118 32 10,119 33 10) | LINESTRING(119 32.5 10,120 33.5 20) z轴没有发生任何变化。 使用三维ST_Affine函数，将z也平移1，转换矩阵： / 1 0 0 1 \\ | 0 1 0 0.5 | | 0 0 1 1 | \\ 0 0 0 1 / 则套入三维的仿射变换函数：ST_Affine(geometry geomA, float a, float b, float c, float d, float e, float f, float g, float h, float i, float xoff, float yoff, float zoff)，那么a=1,b=0,c=0,xoff=1,d=0,e=1,f=0,yoff=0.5,g=0,h=0,i=1,zoff=1。 select st_astext(geom) geom1,st_astext(ST_Affine(geom, 1, 0,0, 0, 1,0,0,0,1, 1, 0.5,1)) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(118 32 10, 119 33 20)') As geom) as foo; geom1 | geom2 --------------------------------------------------------- LINESTRING(118 32 10,119 33 20) | LINESTRING(119 32.5 11,120 33.5 21) z轴从10,20分别平移到了11，21 结论：二维ST_Affine只是三维ST_Affine函数的一个特殊形式。 旋转 将输入二维线旋转30度(pi()*30.0/180)，绕原点转换矩阵参数： / cos(pi()/6) -sin(pi()/6) 0 \\ | sin(pi()/6) cos(pi()/6) 0 | \\ 0 0 1 / 执行转换： select st_astext(geom) geom1,st_astext(ST_Affine(geom, cos(pi()/6), -sin(pi()/6), sin(pi()/6), cos(pi()/6),0,0)) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(1 1, 2 2)') As geom) as foo; geom1 | geom2 ------------------------------------------------------------------------------------------------------------------- LINESTRING(1 1,2 2) | LINESTRING(0.366025403784439 1.36602540378444,0.732050807568878 2.73205080756888) 名词解析： 原点：二维是指向0 0的，如图可清晰可见。 旋转角度：旋转中心点默认是原点，旋转角度为正，逆时针旋转，旋转角度为负，顺时针旋转。 组合 旋转后的效果，与很多人想的不一样，因为旋转是基于原点0 0 旋转的，很多人需要的数据是基于原图形的中心点原地旋转。这样的操作实际上是一个 旋转+平移的组合效果，即将旋转后的图形，平移到原图形的中心点处： 对二维图形LINESTRING(118 32, 119 33)原地旋转（其实就是绕自己的中心点x=118.5 y=32.5旋转），转换矩阵参数： / cos(pi()/6) -sin(pi()/6) x-x*cos(pi()/6)+y*sin(pi()/6) \\ | sin(pi()/6) cos(pi()/6) y-x*sin(pi()/6)-y*cos(pi()/6) | \\ 0 0 1 / select st_astext(geom) geom1,st_astext(ST_Affine(geom, cos(pi()/6), -sin(pi()/6), sin(pi()/6), cos(pi()/6),118.5-118.5*cos(pi()/6)+32.5*sin(pi()/6),32.5-118.5*sin(pi()/6)-32.5*cos(pi()/6))) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(118 32, 119 33)') As geom) as foo; geom1 | geom2 ------------------------------------------------------------------------------------------------------------------- LINESTRING(118 32 10,119 33 20) | LINESTRING(118.316987298108 31.8169872981078,118.683012701892 33.1830127018922) 如果我们分解看，先旋转，再平移同样得到这样的效果： --旋转 select st_astext(ST_Affine(geom, cos(pi()/6), -sin(pi()/6), sin(pi()/6), cos(pi()/6),0,0)) geom from (SELECT ST_GeomFromEWKT('LINESTRING(118 32, 119 33)') As geom) as foo; geom ------------------------------------------------------------------------------------------------------------------- LINESTRING(86.1909976465638 86.712812921102,86.5570230503482 88.0788383248865) --平移 select st_astext(ST_Affine(geom, 1, 0, 0, 1, 118.5-118.5*cos(pi()/6)+32.5*sin(pi()/6),32.5-118.5*sin(pi()/6)-32.5*cos(pi()/6))) geom from (SELECT ST_GeomFromEWKT('LINESTRING(86.1909976465638 86.712812921102,86.5570230503482 88.0788383248865)') As geom) as foo; geom ------------------------------------------------------------------------------------------------------------------- LINESTRING(118.316987298108 31.8169872981077,118.683012701892 33.1830127018923) 最终结果与组合示例sql中的geom2值相等。 缩放 对图形缩放的话，尤其矢量，在gis中应用场景很小。 对xy轴缩小0.5，转换矩阵参数： / sx 0 0 \\ | 0 sy 0 | \\ 0 0 1 / 转换sql： select st_astext(geom) geom1,st_astext(ST_Affine(geom, 0.5,0, 0, 0.5,0,0)) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(118 32, 119 33)') As geom) as foo; geom1 | geom2 ------------------------------------------------------------------------ LINESTRING(118 32, 119 33) | LINESTRING(59 16,59.5 16.5) 结论：这个scale也是基于原点去计算的，所以两个图形相差比较远。 通过缩放再平移，也就是平移到原图形的中心点处，实现原地缩放，转换矩阵参数： / sx 0 118.5/2 \\ | 0 sy 32.5/2 | \\ 0 0 1 / select st_astext(geom) geom1,st_astext(ST_Affine(geom, 0.5,0, 0, 0.5,59.25,16.25)) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(118 32, 119 33)') As geom) as foo; geom1 | geom2 ------------------------------------------------------------------- LINESTRING(118 32, 119 33) | LINESTRING(118.25 32.25,118.75 32.75) 剪切 剪切变换（Shear）其实对gis矢量数据来说也很少用，简单做个介绍。 不考虑平移的话，剪切变换转换矩阵： / 1 shx 0 \\ | shy 1 0 | \\ 0 0 1 / 示例sql： select st_astext(geom) geom1,st_astext(ST_Affine(geom, 1,0.1, 0.1, 1,0,0)) geom2 from (SELECT ST_GeomFromEWKT('Polygon((0 0, 0 1,1 1,1 0,0 0))') As geom) as foo; geom1 | geom2 ------------------------------------------------------------------- POLYGON((0 0,0 1,1 1,1 0,0 0)) | POLYGON((0 0,0.1 1,1.1 1.1,1 0.1,0 0)) 说明：shx，shy其实不是很清楚，看着上图的结果，有点感觉，但是不是很清楚，我们使用更多的例子说明，先将最小点从0 0平移到1 1： select st_astext(geom) geom1,st_astext(ST_Affine(geom, 1,0.1, 0.1, 1,0,0)) geom2 from (SELECT ST_GeomFromEWKT('Polygon((1 1, 1 2,2 2,2 1,1 1))') As geom) as foo; geom1 | geom2 ------------------------------------------------------------------------------------ Polygon((1 1, 1 2,2 2,2 1,1 1)) | POLYGON((1.1 1.1,1.2 2.1,2.2 2.2,2.1 1.2,1.1 1.1)) 最小点从0 0平移到2 2： select st_astext(geom) geom1,st_astext(ST_Affine(geom, 1,0.1, 0.1, 1,0,0)) geom2 from (SELECT ST_GeomFromEWKT('Polygon((2 2, 2 3,3 3,3 2,2 2))') As geom) as foo; geom1 | geom2 ------------------------------------------------------------------------------------ POLYGON((2 2,2 3,3 3,3 2,2 2)) | POLYGON((2.2 2.2,2.3 3.2,3.3 3.3,3.2 2.3,2.2 2.2)) 结论：剪切变换计算也是基于原点0 0计算的，数据越大，两个图形剪切后就会相隔越远。shx，shy可以用下面的示意图表示： 扩展说明 gis中常用的旋转平移缩放使用ST_Affine函数都能实现，高级变换只能使用ST_Affine函数。但是ST_Affine函数偏底层算法，尤其矩阵参数不容易记住，因此，所有的前端api还是服务端或者数据库端，都为应用者封装了一些新的api，在postgis中对应关系如下： ST_Affine旋转对应封装后的ST_Rotate函数。 ST_Affine平移对应封装后的ST_Translate函数。 ST_Affine缩放对应封装后的ST_Scale函数。 封装函数只是为了便于开发，本质其实还是对ST_Affine函数的封装而已。 但是封装后的gis函数和ST_Affine函数有些区别： 当只对图形进行一次操作，如仅仅平移或仅仅旋转，使用ST_Translate或ST_Rotate函数更方便直接，在效率上，封装函数与ST_Affine函数一样。 当对图形进行多次变换，例如某个场景既要平移，也要旋转（既要平移也要旋转也有单独的封装函数，这里只是故意单独作反例说明），使用封装函数方式：ST_Rotate(ST_Translate(geom))，是两个函数叠加使用，也就是一个图形计算了两次；而使用ST_Affine仅仅计算一次。也就是在多次变换这种操作，数据量又特别大，封装函数导致cpu放大，效率低，而ST_Affine函数不存在这个问题。 封装函数只能实现简单的变换操作，使用简单；高级变换如剪切变换都只能使用ST_Affine函数实现，使用抽象点。 "},"vector_function/AffineTransformations/ST_Rotate.html":{"url":"vector_function/AffineTransformations/ST_Rotate.html","title":"ST_Rotate","keywords":"","body":"ST_Rotate 方法功能描述 围绕一个原点，对输入图形进行旋转。 函数定义 旋转原点不指定，默认POINT(0 0)： geometry ST_Rotate(geometry geomA, float rotRadians); 输入参数： geomA：输入图形，该图形将被旋转。 rotRadians：旋转角度，弧度制，例如旋转30°，则该值为pi()*(30.0/180)。旋转基准方向为逆时针。 旋转原点为xy声明形式： geometry ST_Rotate(geometry geomA, float rotRadians, float x0, float y0); 输入参数： x0:旋转原点x坐标。 y0:旋转原点y坐标。 旋转原点为point形式： geometry ST_Rotate(geometry geomA, float rotRadians, geometry pointOrigin); 输入参数： pointOrigin:旋转原点，为point对象，如设置旋转原点是POINY(118 32)。 应用示例 不指定原点，默认原点是0 0： select st_astext(geom) geom1,st_astext(ST_Rotate(geom,pi()*30.0/180)) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(1 1, 2 2)') As geom) as foo; geom1 | geom2 ------------------------------------------------------------------------------------------------------------------- LINESTRING(1 1,2 2) | LINESTRING(0.366025403784439 1.36602540378444,0.732050807568878 2.73205080756888) 指定xy： select st_astext(geom) geom1,st_astext(ST_Rotate(geom,pi()*30.0/180,118.5,32.5)) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(118 32, 119 33)') As geom) as foo; geom1 | geom2 ------------------------------------------------------------------------------------------------------------------- LINESTRING(118 32 10,119 33 20) | LINESTRING(118.316987298108 31.8169872981078,118.683012701892 33.1830127018922) 指定point： select st_astext(geom) geom1,st_astext(ST_Rotate(geom,pi()*30.0/180,ST_MakePoint(118.5,32.5))) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(118 32, 119 33)') As geom) as foo; geom1 | geom2 ------------------------------------------------------------------------------------------------------------------- LINESTRING(118 32 10,119 33 20) | LINESTRING(118.316987298108 31.8169872981078,118.683012701892 33.1830127018922) 说明：以二维举例来说，ST_Rotate其实是ST_Affine(geom, cos(rotRadians), -sin(rotRadians), sin(rotRadians), cos(rotRadians),x-xcos(rotRadians)+ysin(rotRadians),y-xsin(rotRadians)-ycos(rotRadians))的简写。 ST_Rotate实现的功能，使用ST_Affine都能实现，只是ST_Affine偏底层，使用比ST_Rotate复杂点，但是能实现更多高级的仿射变换。 "},"vector_function/AffineTransformations/ST_RotateX.html":{"url":"vector_function/AffineTransformations/ST_RotateX.html","title":"ST_RotateX","keywords":"","body":"ST_RotateX 方法功能描述 对输入图形围绕x轴旋转一定角度（弧度制），输出一个旋转后的新图形。 函数定义 geometry ST_RotateX(geometry geomA, float rotRadians); 参数说明： geomA:输入图形。 rotRadians：绕x轴旋转角度，方向为逆时针方向。 应用示例 为方便展示，把x轴坐标统一写0，即将xyz三维，降维到yz二维，方便读者理解。（三维人脑不好理解）。 示例：对已知线LINESTRING(0 0 0, 0 1 1)围绕x轴旋转90度。 SELECT ST_AsEWKT(ST_RotateX(ST_GeomFromEWKT('LINESTRINGZ(0 0 0, 0 1 1)'), pi()/2)); st_asewkt ------------------------------ LINESTRINGZ(0 0 0,0 -1 1) 说明:ST_RotateX(geomA, rotRadians)是ST_Affine(geomA, 1, 0, 0, 0,cos(rotRadians), -sin(rotRadians), 0, sin(rotRadians), cos(rotRadians), 0,0, 0)的缩写，是围绕x轴旋转场景下的一种封装和应用简化。 "},"vector_function/AffineTransformations/ST_RotateY.html":{"url":"vector_function/AffineTransformations/ST_RotateY.html","title":"ST_RotateY","keywords":"","body":"ST_RotateY 方法功能描述 对输入图形围绕y轴旋转一定角度（弧度制），输出一个旋转后的新图形。 函数定义 geometry ST_RotateY(geometry geomA, float rotRadians); 参数说明： geomA:输入图形。 rotRadians：绕y轴旋转角度，方向为逆时针方向。 应用示例 为方便展示，把y轴坐标统一写0，即将xyz三维，降维到xz二维，方便读者理解。（三维人脑不好理解）。 示例：对已知线LINESTRING(0 0 0, 1 0 1)围绕y轴旋转90度。 SELECT ST_AsEWKT(ST_RotateY(ST_GeomFromEWKT('LINESTRINGZ(0 0 0, 1 0 1)'), pi()/2)); st_asewkt ------------------------------ LINESTRINGZ(0 0 0,1 0 -1) 说明:ST_RotateY(geomA, rotRadians)是ST_Affine(geomA, cos(rotRadians), 0,sin(rotRadians), 0, 1, 0, -sin(rotRadians), 0, cos(rotRadians), 0, 0, 0).的缩写，是围绕y轴旋转场景下的一种封装和应用简化。 "},"vector_function/AffineTransformations/ST_RotateZ.html":{"url":"vector_function/AffineTransformations/ST_RotateZ.html","title":"ST_RotateZ","keywords":"","body":"ST_RotateZ 方法功能描述 对输入图形围绕z轴旋转一定角度（弧度制），输出一个旋转后的新图形。ST_RotateZST_Rotate(geometry geomA, float rotRadians)是完全一样的。 函数定义 geometry ST_RotateZ(geometry geomA, float rotRadians); 参数说明： geomA:输入图形。 rotRadians：绕z轴旋转角度，方向为逆时针方向。 应用示例 为方便展示，把z轴坐标统一写0，即将xyz三维，降维到xy二维，方便读者理解。（三维人脑不好理解）。 示例：对已知线LINESTRING(0 0 0, 1 1 0)围绕z轴旋转90度。 SELECT ST_AsEWKT(ST_RotateZ(ST_GeomFromEWKT('LINESTRINGZ(0 0 0, 1 1 0)'), pi()/2)); st_asewkt ------------------------------ LINESTRINGZ(0 0 0,-1 1 0) 说明:ST_RotateZ(geomA, rotRadians)是SELECT ST_Affine(geomA, cos(rotRadians), -sin(rotRadians), 0, sin(rotRadians), cos(rotRadians), 0,0, 0, 1, 0, 0, 0)的缩写，是围绕z轴旋转场景下的一种封装和应用简化。 "},"vector_function/AffineTransformations/ST_Scale.html":{"url":"vector_function/AffineTransformations/ST_Scale.html","title":"ST_Scale","keywords":"","body":"ST_Scale 方法功能描述 根据缩放因子对图形进行缩放，返回一个缩放后的新图形。 函数定义 --xyz三维缩放 geometry ST_Scale(geometry geomA, float XFactor, float YFactor, float ZFactor); --xy二维缩放 geometry ST_Scale(geometry geomA, float XFactor, float YFactor); --xy,xyz,xym,xyzm都可以用这个重载函数实现 geometry ST_Scale(geometry geom, geometry factor); geometry ST_Scale(geometry geom, geometry factor, geometry origin); 说明：ST_Scale支持xy轴，xyz轴，xym轴，xyzm轴等任意2-4维的缩放，缩放函数是基于默认原点0 0的，有些场景需要图形原地缩放，那么就需要使用ST_Scale(geometry geom, geometry factor, geometry origin)重载函数，origin设置为原图形的质心即可。 应用示例 二维缩放： select ST_AsEWKT(st_scale(ST_GeomFromEWKT('LINESTRING(0 0, 4 4)'),0.5,0.5)); st_asewkt -------------------- LINESTRING(0 0,2 2) 三维z缩放： select ST_AsText(st_scale(ST_GeomFromEWKT('LINESTRINGZ(0 0 0, 4 4 4)'),0.5,0.5,0.5)); st_astext -------------------------- LINESTRING Z (0 0 0,2 2 2) 三维m缩放： 使用xy轴缩放函数： select ST_AsText(st_scale(ST_GeomFromEWKT('LINESTRINGM(0 0 0, 4 4 4)'),0.5,0.5)); st_astext -------------------------- LINESTRING M (0 0 0,2 2 4) 使用xyz轴缩放函数： select ST_AsText(st_scale(ST_GeomFromEWKT('LINESTRINGM(0 0 0, 4 4 4)'),0.5,0.5,0.5)); st_astext -------------------------- LINESTRING M (0 0 0,2 2 4) xy和xyz缩放函数，对m值没任何影响，对m值缩放应使用ST_Scale(geometry geom, geometry factor)重载函数，如下： select ST_AsText(st_scale(ST_GeomFromEWKT('LINESTRINGM(0 0 0, 4 4 4)'),ST_MakePointM(0.5,0.5,0.5))); st_astext -------------------------- LINESTRING M (0 0 0,2 2 2) 第二个参数geometry factor其实是个二维或者三维或者四维点，坐标其实都是缩放因子，比如我想对xym轴都缩放0.5，就定义factor=ST_MakePointM(0.5,0.5,0.5)，如果我想定义xyz都缩放0.5，就定义factor=ST_MakePoint(0.5,0.5,0.5)，如下对xyz缩放0.5所示： ST_MakePoint函数有几个重载函数，如ST_MakePoint(x,y),ST_MakePoint(x,y,z),ST_MakePoint(x,y,z,m)，单独构造xym是ST_MakePointM(x,y,m)。 select ST_AsText(st_scale(ST_GeomFromEWKT('LINESTRINGZ(0 0 0, 4 4 4)'),ST_MakePoint(0.5,0.5,0.5))); st_astext -------------------------- LINESTRING Z (0 0 0,2 2 2) 四维xyzm： select ST_AsText(st_scale(ST_GeomFromEWKT('LINESTRINGZM(0 0 0 0, 4 4 4 4)'),ST_MakePoint(0.5,0.5,0.5,0.5))); st_astext -------------------------- LINESTRING ZM (0 0 0 0,2 2 2 2) 结论：ST_Scale(geometry geom, geometry factor)比较通用，ST_Scale(geometry geomA, float XFactor, float YFactor, float ZFactor)与ST_Scale(geometry geomA, float XFactor, float YFactor)只是ST_Scale(geometry geom, geometry factor)的特殊形式。 指定原点缩放： --对输入线原地缩放，指定缩放原点为原图形LINESTRING(118 32, 119 33)的几何质心118.5,32.5。 select st_astext(geom) geom1,st_astext(ST_Scale(geom, st_makepoint(0.5,0.5), st_makepoint(118.5,32.5))) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(118 32, 119 33)') As geom) as foo; geom1 | geom2 ------------------------------------------------------------------- LINESTRING(118 32, 119 33) | LINESTRING(118.25 32.25,118.75 32.75) ST_Scale仍然是ST_Affine的一个缩放场景的特例封装和简化。 "},"vector_function/AffineTransformations/ST_Translate.html":{"url":"vector_function/AffineTransformations/ST_Translate.html","title":"ST_Translate","keywords":"","body":"ST_Translate 方法功能描述 根所设置的偏移量，对输入图形进行坐标平移，返回一个新的平移后的图形。 函数定义 二维： geometry ST_Translate(geometry g1, float deltax, float deltay); 三维： geometry ST_Translate(geometry g1, float deltax, float deltay, float deltaz); 应用示例 二维： select st_astext(geom) geom1,st_astext(ST_Translate(geom, 1, 0.5)) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(118 32, 119 33)') As geom) as foo; geom1 | geom2 --------------------------------------------------------- LINESTRING(118 32,119 33) | LINESTRING(119 32.5,120 33.5) 使用二维的ST_Affine，等同于对三维的z不处理，如下： select st_astext(geom) geom1,st_astext(ST_Translate(geom, 1, 0.5)) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(118 32 10, 119 33 20)') As geom) as foo; geom1 | geom2 --------------------------------------------------------- LINESTRING(118 32 10,119 33 10) | LINESTRING(119 32.5 10,120 33.5 20) z轴没有发生任何变化。 三维： select st_astext(geom) geom1,st_astext(ST_Translate(geom, 1, 0.5,-1)) geom2 from (SELECT ST_GeomFromEWKT('LINESTRING(118 32 10, 119 33 20)') As geom) as foo; geom1 | geom2 --------------------------------------------------------- LINESTRING(118 32 10,119 33 10) | LINESTRING Z (119 32.5 9,120 33.5 19) z轴都减少了1。 结论：ST_Translate是ST_Affine平移场景的封装和简化写法。 "},"vector_function/AffineTransformations/ST_TransScale.html":{"url":"vector_function/AffineTransformations/ST_TransScale.html","title":"ST_TransScale","keywords":"","body":"ST_TransScale 方法功能描述 对输入图形先根据平移量平移，再根据缩放因子进行缩放，返回一个新图形，仅仅用于二维图形。 函数定义 geometry ST_TransScale(geometry geomA, float deltaX, float deltaY, float XFactor, float YFactor); 参数说明： geomA:输入图形。 deltaX：x方向偏移量。 deltaY：y方向偏移量。 XFactor：x轴缩放因子。 YFactor：y轴缩放因子。 应用示例 对LINESTRING(0 0, 3 3)先平移1 1，再缩放0.5，0.25： --平移后(0 0, 3 3)变成(1 1,4 4)，xy值分别再缩放放0.5，0.25 SELECT ST_AsEWKT(ST_TransScale(ST_GeomFromEWKT('LINESTRING(0 0, 3 3)'), 1,1,0.5,0.25)); st_Asewkt ------------------------- LINESTRING(0.5 0.25,2 1) ST_TransScale(geomA, deltaX, deltaY, XFactor, YFactor)是ST_Affine(geomA, XFactor, 0, 0, 0, YFactor, 0, 0, 0, 1, deltaXXFactor,deltaYYFactor, 0)的简写。 "},"vector_function/Clustering.html":{"url":"vector_function/Clustering.html","title":"8.15 空间聚类","keywords":"","body":"ST_ClusterDBSCAN 方法功能描述 窗口函数，基于DBSCAN算法，返回每一个输入的geometry所对应的聚类id。 函数定义 integer ST_ClusterDBSCAN(geometry winset geom, float8 eps, integer minpoints); 入参： geom：输入的2d图形。 eps：聚类距离，当两个图形之间距离小于聚类距离，他们被归为一类。 minpoints：规定“簇”中至少包含的图形数量。 返回值：对应的聚类id号，如果输入的geom不属于任何一个“簇”，将返回null。 应用示例 从osm的building图层中截取了一小部分测试房屋建筑数据，基于ST_ClusterDBSCAN方法，根据建筑之间小于20米，且每一簇中至少包含2个图形： --表坐标系是epsg:4326的经纬度，所以这里是使用0.0002大概模拟20米，非真实距离。 SELECT gid,name, ST_ClusterDBSCAN(geom, eps:= 0.0002, minpoints := 2) over () AS cid FROM buildings; gid | name | cid -----+--------------+----- 1 | | 2 | | 2 3 | | 2 4 | | 2 5 | 大洋百货 | 6 | 商茂世纪广场 | 0 7 | 华威大厦 | 2 8 | 天安保险大厦 | 2 9 | | 2 10 | | 11 | 江苏交通大厦 | 2 12 | 阳光大厦 | 13 | | 0 14 | | 2 15 | | 2 16 | | 2 17 | | 2 18 | | 1 19 | | 1 20 | | 2 21 | | 2 22 | | 2 23 | | 2 24 | | 2 25 | | 2 26 | | 2 27 | | 2 -- More -- cid是每个geom所对应建筑的聚类id号，灰色建筑是与其他图形之间距离大于20米，所以没有归入任何一个“簇”，返回的聚类id是null(cid null的记录都是灰色的)。 ST_ClusterIntersecting 方法功能描述 聚合函数，对于输入的一个geometry集合，集合中图形之间根据“空间相交”进行聚类，最后把聚类结果聚合成一个geometry数组，数组里的每一项代表“一类”。 函数定义 geometry[] ST_ClusterIntersecting(geometry set g); 入参： g：输入的2d图形集合。 返回值：所有的图形完成聚类，每一类图形都是一个GEOMETRYCOLLECTION（图形集合）对象，所有类都塞入一个geometry数组里并返回结果。 应用示例 示例数据示意图如下： 先构造测试数据： create table building2( gid serial primary key, name text, geom geometry(Polygon,4326) ); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.77376608689 32.0424742122357,118.774542742962 32.0416518705121,118.773994515147 32.0411036426964,118.773172173423 32.0418802987687,118.77376608689 32.0424742122357))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.774222943403 32.0429310687489,118.775898083951 32.0413320709528,118.775456455989 32.0407838431371,118.774542742962 32.0416518705121,118.77376608689 32.0424742122357,118.774222943403 32.0429310687489))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.775898083951 32.0413320709528,118.777055453785 32.0402813009728,118.776629054372 32.0397635302578,118.775456455989 32.0407838431371,118.775898083951 32.0413320709528))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.771192461866 32.0393066737446,118.772684859809 32.0389259599839,118.772258460397 32.0379208756551,118.770705148252 32.0383320465169,118.771192461866 32.0393066737446))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.772258460397 32.0379208756551,118.772684859809 32.0389259599839,118.774375228908 32.0384234178194,118.773964058046 32.0375097047933,118.772258460397 32.0379208756551))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.776766111326 32.0381188468106,118.778045309563 32.0377076759488,118.778167137966 32.0373117336375,118.777695052903 32.0366721345192,118.776080826556 32.0371746766835,118.776766111326 32.0381188468106))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.778700137232 32.0380274755081,118.779857507065 32.0373878763897,118.779461564754 32.0368853342252,118.778730594333 32.0369614769774,118.778167137966 32.0373117336375,118.778045309563 32.0377076759488,118.778700137232 32.0380274755081))',4326)); 聚类结果示意图如下： 执行聚类： select st_astext(unnest(ST_ClusterIntersecting(geom))) from building2; st_astext ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- GEOMETRYCOLLECTION(POLYGON((118.77376608689 32.0424742122357,118.774542742962 32.0416518705121,118.773994515147 32.0411036426964,118.773172173423 32.0418802987687,118.77376608689 32.0424742122357)),POLYGON((118.774222943403 32.0429310687489,118.775898083951 32.0413320709528,118.775456455989 32.0407838431371,118.774542742962 32.0416518705121,118.77376608689 32.0424742122357,118.774222943403 32.0429310687489)),POLYGON((118.775898083951 32.0413320709528,118.777055453785 32.0402813009728,118.776629054372 32.0397635302578,118.775456455989 32.0407838431371,118.775898083951 32.0413320709528))) GEOMETRYCOLLECTION(POLYGON((118.771192461866 32.0393066737446,118.772684859809 32.0389259599839,118.772258460397 32.0379208756551,118.770705148252 32.0383320465169,118.771192461866 32.0393066737446)),POLYGON((118.772258460397 32.0379208756551,118.772684859809 32.0389259599839,118.774375228908 32.0384234178194,118.773964058046 32.0375097047933,118.772258460397 32.0379208756551))) GEOMETRYCOLLECTION(POLYGON((118.776766111326 32.0381188468106,118.778045309563 32.0377076759488,118.778167137966 32.0373117336375,118.777695052903 32.0366721345192,118.776080826556 32.0371746766835,118.776766111326 32.0381188468106)),POLYGON((118.778700137232 32.0380274755081,118.779857507065 32.0373878763897,118.779461564754 32.0368853342252,118.778730594333 32.0369614769774,118.778167137966 32.0373117336375,118.778045309563 32.0377076759488,118.778700137232 32.0380274755081))) (3 行记录) 使用问题 ST_ClusterIntersecting是个聚合函数，聚类的结果最后是一个geometry[]类型，没有任何属性字段，有时候我们其实聚类后，想要获取聚类图形结果与属性关系，比如我们没办法从ST_ClusterIntersecting函数的结果中输出对应的gid或者name等其他更多信息。 解决方法目前只能通过图形之间的关系去解决。 第一步：给原图形新增一列，存储一个必须在原图形内部的点： alter table building2 add column centroid geometry(point,4326); update building2 set centroid=ST_PointOnSurface(geom); 第二步：给聚类函数返回一个随机的聚类id： create extension \"uuid-ossp\"; --聚类中的每一组，都被分配了一个随机的聚类id create table temp_ClusterIntersecting( cid uuid, geom geometry ); insert into temp_ClusterIntersecting select uuid_generate_v4(),unnest(ST_ClusterIntersecting(geom)) from building2; 第三步：返回要素id和对应聚类id： select b.gid,a.cid a from temp_ClusterIntersecting a, building2 b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 4 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 5 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 6 | \"86daef2f-5cae-4a65-8208-433bf0c525e0\" 7 | \"86daef2f-5cae-4a65-8208-433bf0c525e0\" 也可以合起来写： select b.gid,a.cid from (select uuid_generate_v4() as cid,unnest(ST_ClusterIntersecting(geom)) as geom from building2) a, (select gid,ST_PointOnSurface(geom) as centroid from building2) b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 4 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 5 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 6 | \"86daef2f-5cae-4a65-8208-433bf0c525e0\" 这样，通过gid能关联得到每个记录对应的其他更多字段信息，通过cid知道哪些记录是一组的等其他操作。 注意：关于join和空间查询性能不是本节主要阐述重点，本节提出的方案是理论可行方案，但是基于实际项目和数据，存在优化空间，需要根据其他postgis优化方案进行处理。 ST_ClusterKMeans 方法功能描述 窗口函数，基于K-means算法，返回每一个输入的geometry所对应的聚类id。 函数定义 integer ST_ClusterKMeans(geometry winset geom, integer number_of_clusters); 入参： geom：输入的2d图形。 number_of_clusters：均值中心聚类指定“簇”的数量。 返回值：对应的聚类id号，如果输入的geom不属于任何一个“簇”，将返回null 应用示例 从osm的building图层中截取了一小部分测试房屋建筑数据，基于ST_ClusterKMeans空间聚合，指定分类数量为3，返回每个记录的id和对应的聚类id（cid）号： SELECT gid,ST_ClusterKMeans(geom,3) over () AS cid,geom FROM buildings; 指定分类数量为4： SELECT gid,ST_ClusterKMeans(geom,4) over () AS cid,geom FROM buildings; ST_ClusterWithin 方法功能描述 聚合函数，对输入的图形集合，如果图形之间的距离在指定的距离内，则归并为一类。与ST_ClusterIntersecting类似，只是ST_ClusterIntersecting指定是图形必须相交，可以认为距离是0，而ST_ClusterWithin不需要图形之间相交关系，而是说即使图形不相交，但是当图形的距离在所规定的容差内，就可认为他们是一类。 函数定义 geometry[] a(geometry set g, float8 distance); 入参： g：输入的2d图形集合。 distance：距离容差。 返回值：所有的图形完成聚类，每一类图形都是一个GEOMETRYCOLLECTION（图形集合）对象，所有类都塞入一个geometry数组里并返回结果。 应用示例 从osm的building图层中截取了一小部分测试房屋建筑数据，基于ST_ClusterWithin空间聚类，指定聚类条件是图形间的距离小于50米： select unnest(ST_ClusterWithin(geom, 0.0005)) geom from buildings; 指定聚类条件是图形间的距离小于30米： select unnest(ST_ClusterWithin(geom, 0.0003)) geom from buildings; 使用问题 ST_ClusterWithin是个聚合函数，聚类的结果最后是一个geometry[]类型，没有任何属性字段，有时候我们其实聚类后，想要获取聚类图形结果与属性关系，比如我们没办法从ST_ClusterWithin函数的结果中输出对应的gid或者name等其他更多信息。 解决方法目前只能通过图形之间的关系去解决。 第一步：给原图形新增一列，存储一个必须在原图形内部的点： alter table buildings add column centroid geometry(point,4326); update buildings set centroid=ST_PointOnSurface(geom); 第二步：给聚类函数返回一个随机的聚类id： create extension \"uuid-ossp\"; --聚类中的每一组，都被分配了一个随机的聚类id create table temp_ClusterWithin( cid uuid, geom geometry ); insert into temp_ClusterWithin select uuid_generate_v4(),unnest(ST_ClusterWithin(geom，0.0005)) from buildings; 第三步：返回要素id和对应聚类id： select b.gid,a.cid a from temp_ClusterWithin a, buildings b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" (More rows) 也可以合起来写： select b.gid,a.cid from (select uuid_generate_v4() as cid,unnest(ST_ClusterWithin(geom，0.0005))) as geom from buildings) a, (select gid,ST_PointOnSurface(geom) as centroid from buildings) b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" (More rows) 这样，通过gid能关联得到每个记录对应的其他更多字段信息，通过cid知道哪些记录是一组的等其他操作。 注意：关于join和空间查询性能不是本节主要阐述重点，本节提出的方案是理论可行方案，但是基于实际项目和数据，存在优化空间，需要根据其他postgis优化方案进行处理。 "},"vector_function/LinearReferencing/ST_LineInterpolatePoint.html":{"url":"vector_function/LinearReferencing/ST_LineInterpolatePoint.html","title":"8.16 线性参考","keywords":"","body":"ST_LineInterpolatePoint 方法功能描述 根据百分比返回单义线上任意点的位置。 函数定义 geometry ST_LineInterpolatePoint(geometry a_linestring, float8 a_fraction); 入参： a_linestring：一条线，必须是LineString类型，不支持MultiLineString； a_fraction：百分比，0-1之间的一个小数。 返回值： 一个点图形对象。 应用示例 返回线的中点位置： --中点对应的百分比是0.5，起点对应0，终点对应1 SELECT ST_AsText(ST_LineInterpolatePoint(the_line, 0.50)) FROM (SELECT ST_GeomFromText('LINESTRING(118 32,119 33)') as the_line) As foo; st_astext ------------------- POINT(118.5 32.5) (1 行记录) 返回线的起点位置： SELECT ST_AsText(ST_LineInterpolatePoint(the_line, 0)) FROM (SELECT ST_GeomFromText('LINESTRING(118 32,119 33)') as the_line) As foo; st_astext ------------------- POINT(118 32) (1 行记录) 返回线的终点位置： SELECT ST_AsText(ST_LineInterpolatePoint(the_line, 1)) FROM (SELECT ST_GeomFromText('LINESTRING(118 32,119 33)') as the_line) As foo; st_astext ------------------- POINT(119 33) (1 行记录) 多维应用 ST_LineInterpolatePoint函数能部分满足多维应用，PostGIS中常用的有 经度纬度高程(lon,lat,z)这样的三维数据，还有 经度纬度测量值(lon,lat,m)这样的测量值坐标。分别举例如下： --带高程z SELECT ST_AsText(ST_LineInterpolatePoint(the_line, 0.5)) FROM (SELECT ST_GeomFromText('LINESTRINGZ(1 1 6, 3 1 3, 3 3 8)') as the_line) As foo; st_astext ------------------- POINT Z(3 1 3) (1 行记录) --带测量值m SELECT ST_AsText(ST_LineInterpolatePoint(the_line, 0.5)) FROM (SELECT ST_GeomFromText('LINESTRINGM(1 1 6, 3 1 3, 3 3 8)') as the_line) As foo; st_astext ------------------- POINT M(3 1 3) (1 行记录) --既有高程z，也有测量值m SELECT ST_AsText(ST_LineInterpolatePoint(the_line, 0.5)) FROM (SELECT ST_GeomFromText('LINESTRINGZM(1 1 6 8, 3 1 3 6, 3 3 8 7)') as the_line) As foo; st_astext ------------------- POINT M(3 1 3 6) (1 行记录) 现象：ST_LineInterpolatePoint只是根据经纬度和百分比算位置的，无论后面z还和m是什么值对于平面的中点位置其实没有任何影响。计算出实际位置后，才插值计算该点对应的z，m值。 说明：位置点的计算，与高程z毫无关系，其实等于说明，不支持真实的带高程z的三维图形计算，三维中的位置点计算另有函数实现。 ST_3dLineInterpolatePoint 该函数使用与ST_LineInterpolatePoint一模一样，但是支持三维高程数据，下面举几个案例说明： 高程z计算 SELECT ST_AsText(ST_3dLineInterpolatePoint(the_line, 0.5))FROM (SELECT ST_GeomFromText('LINESTRINGZ(1 1 6, 3 1 3, 3 3 8)') as the_line) As foo; st_astext ----------------------------------------------- POINT Z (3 1.33046593658801 3.82616484147003) (1 行记录) 说明：计算结果不同于ST_LineInterpolatePoint，ST_3dLineInterpolatePoint计算结果已经考虑了三维z值对位置的影响。 测量值m计算 SELECT ST_AsText(ST_3dLineInterpolatePoint(the_line, 0.5))FROM (SELECT ST_GeomFromText('LINESTRINGM(1 1 6, 3 1 3, 3 3 8)') as the_line) As foo; st_astext ----------------------------------------------- POINT M(3 1 3) (1 行记录) 说明：线型为LINESTRINGM，没有申明z值，此为特殊情况，可以理解成线上的点的z值都是同一个默认值z（比如0），那么在默认值z的维度下（降维打击？？？），这个线其实是个标准的平面二维数据，所以ST_3dLineInterpolatePoint与ST_LineInterpolatePoint结果一致。 例如，当z值相同，可以看成在该维度下是二维的，位置点经纬度结果与二维是一致： SELECT ST_AsText(ST_3dLineInterpolatePoint(the_line, 0.5))FROM (SELECT ST_GeomFromText('LINESTRINGZ(1 1 6, 3 1 6, 3 3 6)') as the_line) As foo; st_astext ----------------------------------------------- POINT M(3 1 6) (1 行记录) 高程z与测量值m计算 SELECT ST_AsText(ST_3dLineInterpolatePoint(the_line, 0.5))FROM (SELECT ST_GeomFromText('LINESTRINGZM(1 1 6 5, 3 1 3 4, 3 3 8 9)') as the_line) As foo; st_astext ----------------------------------------------- POINT ZM (3 1.33046593658801 3.82616484147003 4.82616484147003) (1 行记录) 说明：ST_3dLineInterpolatePoint函数根据经纬度和高程z计算出三维点位置，再根据点位置反向插值计算m值。 总结： ST_LineInterpolatePoint位置点由经纬度参与计算，高程z与测量m值不参与计算。位置点确定后，反向插值计算z，m，仅适合二维。 ST_3dLineInterpolatePoint位置点有经纬度和高程z参与计算，测量值m不参与计算。位置点确定后，反向插值计算m，仅适合三维。 测量值m都不参与位置点计算，而是通过已经计算出的位置点，反向插值推导出该点对应的m值。 ST_LineInterpolatePoints 方法功能描述 根据百分比返回单义线上一到多个的任意点的位置。 函数定义 geometry ST_LineInterpolatePoints(geometry a_linestring, float8 a_fraction,boolean repeat); 入参： a_linestring：一条线，必须是LineString类型，不支持MultiLineString； a_fraction：百分比，0-1之间的一个小数。 repeat：true可重复，如设置0.1，则从0开始，每0.1间隔采一个点；如设置0.6，即使true也只会有一个点。false时等同与ST_LineInterpolatePoint。 返回值： 一到多个点图形对象。返回多个点时是MultiPoint对象，单个点时是Point对象。 使用示例： 设置fraction=0.5，即每0.5位置获取一个点： SELECT ST_AsText(ST_LineInterpolatePoints(the_line, 0.5)) FROM (SELECT ST_GeomFromText('LINESTRING(1 1, 3 1, 3 3)') as the_line) As foo; st_astext ----------------------------------------------- MULTIPOINT(3 1,3 3) (1 行记录) 设置fraction=0.6： SELECT ST_AsText(ST_LineInterpolatePoints(the_line, 0.6)) FROM (SELECT ST_GeomFromText('LINESTRING(1 1, 3 1, 3 3)') as the_line) As foo; st_astext ----------------------------------------------- POINT(3 1.4) (1 行记录) "},"vector_function/LinearReferencing/ST_LineLocatePoint.html":{"url":"vector_function/LinearReferencing/ST_LineLocatePoint.html","title":"ST_LineLocatePoint","keywords":"","body":"ST_LineLocatePoint 方法功能描述 已知一条线和某个点，该点可在线上，也可以不在线上，当点不在线上时，实际上是先从线上计算出与该点最近的点，然后计算位于线上这个点位于线上的[0,1]之间的一个百分比。 函数定义 float8 ST_LineLocatePoint(geometry a_linestring, geometry a_point); 参数定义： a_linestring：一条线，LineString及其扩展类型LineStringZ，LineStringM或者LineStringZM，但是不重要，zm都不会参与计算。 a_point：一个已知点。 使用限制：该函数只适用二维，根本不会考虑三维情况。 应用示例 点在线上常规操作： select ST_LineLocatePoint(st_geomfromtext('LineString(1 1,3 1,3 3)'), st_geomfromtext('Point(3 1)')); st_lineLocatepoint ------------------ 0.5 带z值： select ST_LineLocatePoint(st_geomfromtext('LineStringZ(1 1 6,3 1 3,3 3 8)'), st_geomfromtext('PointZ(3 1 5)')); st_lineLocatepoint ------------------ 0.5 带m值： select ST_LineLocatePoint(st_geomfromtext('LineStringM(1 1 6,3 1 3,3 3 8)'), st_geomfromtext('PointM(3 1 5)')); st_lineLocatepoint ------------------ 0.5 带zm值： select ST_LineLocatePoint(st_geomfromtext('LineStringZM(1 1 6 5,3 1 3 4,3 3 8 5)'), st_geomfromtext('PointZM(3 1 5 5)')); st_lineLocatepoint ------------------ 0.5 点不在线上： select ST_LineLocatePoint(st_geomfromtext('LineString(1 1,3 1,3 3)'), st_geomfromtext('Point(3 4)')); st_lineLocatepoint ------------------ 1 select ST_LineLocatePoint(st_geomfromtext('LineString(1 1,3 1,3 3)'), st_geomfromtext('Point(2.5 2.5)')); st_lineLocatepoint ------------------ 0.875 结论：符合使用限制说明，仅仅用于二维，zm值对计算结果无影响。点不在线上时，实际等同于先根据ST_ClosestPoint函数计算该点对应线上的一个最近点，然后使用最近点计算其在线上的百分比。 典型应用场景 单独使用这个函数比较少，都是结合其他函数一起使用。比如在路径分析中，有起点终点，得到一个完整的路径，路径是由路段拼接的，而起点终点不一定就在路段上，首尾就会有时长一部分有时短一截，显示效果比较差，如下图： 通过ST_LineLocatePoint计算出起点终点在路径上的百分比，然后调用ST_SubString函数根据百分截取一个子路段，可以优化这样的效果，如下图： sql示例： do language plpgsql $$ DECLARE line geometry; --路径 start geometry; --起点 end geometry; --终点 startfraction float; endfraction float; route_path geometry; --最终路径结果 BEGIN line=ST_GeomFromText('LineString(1 1,5 5)'); start:=ST_MakePoint(1.5,1.8); end:=ST_MakePoint(4.9,5.1); startfraction:=ST_LineLocatePoint(line,start); endfraction:=ST_LineLocatePoint(line,end); route_path:=ST_LineSubstring(line,startfraction,endfraction); raise notice '%',st_astext(route_path); end; $$; "},"vector_function/LinearReferencing/ST_LineSubstring.html":{"url":"vector_function/LinearReferencing/ST_LineSubstring.html","title":"ST_LineSubstring","keywords":"","body":"ST_LineSubstring 方法功能描述 根据输入的0-1之间的两个分数，截取两个分数之间的一个子线，使用方式很像字符串截取的函数。 函数定义 geometry ST_LineSubstring(geometry a_linestring, float8 startfraction, float8 endfraction); a_linestring:输入线，必须是LineString及其扩展LineStringM，LineStringZ，LineStringZM类型。 startfraction：0-1之间的一个百分比数。 endfraction：0-1之间的一个百分比数。 当startfraction=endfraction，ST_LineSubstring结果等同于ST_LineInterpolatePoint，仅仅返回一个点。 应用示例 startfraction SELECT ST_AsText(ST_LineSubString(ST_GeomFromText('LINESTRING(118 32,119 33)'), 0.333, 0.666)); st_astext ---------------------------------------- LINESTRING(118.333 32.333,118.666 32.666) startfraction=endfraction SELECT ST_AsText(ST_LineSubString(ST_GeomFromText('LINESTRING(118 32,119 33)'), 0.333, 0.333)); st_astext ---------------------- POINT(118.333 32.333) 当startfraction=endfraction时，ST_LineSubString结果等同于ST_LineInterpolatePoint函数的要实现的功能。 startfraction>endfraction SELECT ST_AsText(ST_LineSubString(ST_GeomFromText('LINESTRING(118 32,119 33)'),0.666, 0.333)); ERROR: 错误: 2nd arg must be smaller then 3rd arg 结论：startfraction一定要小于等于endfraction。 连续的MULTILINESTRINGs 说明：ST_LineSubString仅仅支持LineString及其衍生类型，不支持MULTILINESTRING及其衍生类型。 所以有种特殊情况下，即MULTILINESTRING中的子线都是连续的，那么他们可以合并成一个新的LineString结果。 SELECT ST_AsText(ST_LineSubString(ST_LineMerge(ST_GeomFromText('MULTILINESTRING((118 32,118.5 32.5),(118.5 32.5,119 33))')),0.333, 0.666)); st_astext ---------------------------------------------------- LINESTRING(118.333 32.333,118.5 32.5,118.666 32.666) 由于(118 32,118.5 32.5),(118.5 32.5,119 33)两个子线是连续的，当ST_LineMerge时，会形成一个新的单线LineString(118 32,118.5 32.5,119 33)，以上函数实际是对该LineString做的分段线提取。 "},"vector_function/LinearReferencing/ST_LocateAlong.html":{"url":"vector_function/LinearReferencing/ST_LocateAlong.html","title":"ST_LocateAlong","keywords":"","body":"ST_LocateAlong 方法功能描述 已知一个非面的带M值的图形，输入任意一个M测量值，返回该M值对应的地理位置集合形成的一个图形对象，返回图形都是MULTIPOINTM类型。 函数定义 不输入偏移量： geometry ST_LocateAlong(geometry ageom_with_measure, float8 a_measure); 输入偏移量： geometry ST_LocateAlong(geometry ageom_with_measure, float8 a_measure, float8 offset); 参数定义： ageom_with_measure：必须是POINTM，MULTIPOINTM，LINESTRINGM，MULTILINESTRINGM类型之一，不支持面数据。POINTM只有单个点其实没啥意义，实际可用类型就MULTIPOINTM，LINESTRINGM，MULTILINESTRINGM三种类型，实用类型通常就LINESTRINGM一种情况。 a_measure：测量值数值。 offset：偏移量，意思是生成后的图形相对于原来图形进行偏移，正值是代表生成后的图形相当于原来图形左偏移，负值是相当于原来图形右偏移。 函数定义和说明非常非常抽象！！！ 使用限制：该函数有且仅适用于带测量值M的非面状图形计算。 应用示例 简单线型 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('LINESTRINGM(1 2 4, 3 4 2, 9 4 3)'),3) As the_geom) As foo; st_astext ----------- MULTIPOINT M (2 3 3,9 4 3) 多义线型 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('MULTILINESTRINGM((1 2 3, 3 4 2, 9 4 3),(1 2 3,5 4 5))'),3) As the_geom) As foo; st_astext -------------------------------- MULTIPOINT M (1 2 3,9 4 3,1 2 3) 结果出现了两个（1 2 3）点，原因是上图MULTILINESTRINGM由子线1,2组成的，在计算时，实际会将多义线拆分成单义线，每条线单独计算，从子线1得到 （1 2 3），（9 4 3）两个点，从子线2得到（1 2 3）一个点，合计得到3个点。 多义点类型 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('MULTIPointM(1 2 3, 3 4 2, 9 4 3)'),3) As the_geom) As foo; st_astext -------------------------------- MULTIPOINT M (1 2 3,9 4 3) SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('MULTIPointM(1 2 3, 3 4 2, 9 4 3)'),2.3) As the_geom) As foo; st_astext -------------------------------- MULTIPOINT M EMPTY 多义点不会插值，m值只有“碰”到这个点的m值才行，不会插值，碰不到就返回空。 单点类型 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('PointM(1 2 3)'),3) As the_geom) As foo; st_astext --------------------- MULTIPOINT M (1 2 3) SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('MULTIPointM(1 2 3)'),2.3) As the_geom) As foo; st_astext -------------------- MULTIPOINT M EMPTY 单点和多义点一样，不会插值，m值只有“碰”到这个点的m值才行，不会插值，碰不到就返回空。 简单线型偏移值 --正向偏移 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('LINESTRINGM(1 2 4, 3 4 2, 9 4 3)'),3,1) As the_geom) As foo; st_astext --------------------------------------------------------- MULTIPOINT M (1.29289321881345 3.70710678118655 3,9 5 3) 沿着单义线的前进方向，对原来的结果点向左偏移距离1，形成两个新的结果点。 --负向偏移 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('LINESTRINGM(1 2 4, 3 4 2, 9 4 3)'),3,-1) As the_geom) As foo; st_astext --------------------------------------------------------- MULTIPOINT M (2.70710678118655 2.29289321881345 3,9 3 3) 多义线型偏移值 SELECT ST_AsText(the_geom) FROM (SELECT ST_LocateAlong( ST_GeomFromText('MULTILINESTRINGM((1 2 3, 3 4 2, 9 4 3),(1 2 3,5 4 5))'),3,1) As the_geom) As foo; st_astext --------------------------------------------------------- MULTIPOINT M (0.292893218813453 2.70710678118655 3,9 5 3,0.552786404500042 2.89442719099992 3) 由图可知，即使偏移量，也是分别根据子线1，子线2分别做的偏移。红蓝箭头构成的直角框可知。 "},"vector_function/LinearReferencing/ST_LocateBetween.html":{"url":"vector_function/LinearReferencing/ST_LocateBetween.html","title":"ST_LocateBetween","keywords":"","body":"ST_LocateBetween 方法功能描述 已知一个有测量值的图形，设置一个起点，终点测量值构成的区间，返回区间内的衍生图形集合。 函数定义 geometry ST_LocateBetween(geometry geom, float8 measure_start, float8 measure_end, float8 offset); 入参： geom：带有测量值的M的图形。 measure_start：起点测量值。 measure_end：终点测量值。 offset：偏移量，不指定默认值为0，当偏移量为正，偏移方向是相对于原图形的左边偏移；当偏移量为负，偏移方向相对于原图形的右边偏移。 注意：该函数支持LineString,MultiLineString,POLYGON,MultiPOLYGON,TIN, TRIANGLE图形类型，这些图形必须都带有M测量值。 应用示例 MULTILINESTRINGM 查询m值在1.5到3之间的图形集合，对于子线(1 2 3, 3 4 2, 9 4 3)所有的点m值都大于1.5；对于子线(1 2 3, 5 4 5)只有(1 2)点的M值等于3符合，其他都大于3，不符合。 SELECT ST_AsText(the_geom) FROM ( SELECT ST_LocateBetween( ST_GeomFromtext('MULTILINESTRING M ((1 2 3, 3 4 2, 9 4 3),(1 2 3, 5 4 5))'), 1.5, 3) as the_geom) As foo; st_astext ----------------------------------------------------------------------- GEOMETRYCOLLECTION M (LINESTRING M (1 2 3,3 4 2,9 4 3),POINT M (1 2 3)) 偏移值 --偏移值1是原图形的左边偏移。 SELECT ST_AsText(the_geom) FROM ( SELECT ST_LocateBetween( ST_GeomFromtext('MULTILINESTRING M ((1 2 3, 3 4 2, 9 4 3),(1 2 3, 5 4 5))'), 1.5, 3,1 ) as the_geom ) As foo; --偏移值-1是原图形的右边偏移。 偏移值方向不同，拐角处理原则不同，有圆角和直角，同时，会对部分图形进行合并，比如不偏移会有一个(1 2)单独的点，偏移后被合并到偏移线上了，没有单独的点了。 POLYGONM 从一个面中查询测量值2.5到3之间的面区域。 SELECT ST_AsText(the_geom) FROM ( SELECT ST_LocateBetween( ST_GeomFromtext('POLYGON M ((1 2 3, 1 4 2, 3 4 3,3 2 2,1 2 3))'), 2.5, 3) as the_geom) As foo; st_astext ----------------------------------------------------------------------- MULTIPOLYGON M (((1 2 3,1 3 2.5,2 4 2.5,3 4 3,3 3 2.5,2 2 2.5,1 2 3))) 换成multipolygon: SELECT ST_AsText(the_geom) FROM ( SELECT ST_LocateBetween( ST_GeomFromtext('MultiPOLYGON M (((1 2 3, 1 4 2, 3 4 3,3 2 2,1 2 3)))'), 2.5, 3) as the_geom) As foo; st_astext ----------------------------------------------------------------------- MULTIPOLYGON M (((1 2 3,1 3 2.5,2 4 2.5,3 4 3,3 3 2.5,2 2 2.5,1 2 3))) "},"vector_function/LinearReferencing/ST_LocateBetweenElevations.html":{"url":"vector_function/LinearReferencing/ST_LocateBetweenElevations.html","title":"ST_LocateBetweenElevations","keywords":"","body":"ST_LocateBetweenElevations 方法功能描述 已知一个有高程值z的图形，设置一个起点，终点z值构成的区间，返回区间内的衍生图形集合。该函数与ST_LocateBetween本质一样，只是ST_LocateBetween是处理二维图形含测量值M的情况，计算方式是依据二维几何计算；ST_LocateBetweenElevations是处理三维图形含高程值Z的情况，计算方式是依据三维几何计算。 函数定义 geometry ST_LocateBetweenElevations(geometry geom, float8 elevation_start, float8 elevation_end); 参数定义： geom:输入的一个带有高程值z的图形。LineString，Polygon，TIN, TRIANGLE图形类型。 elevation_start：起点海拔。 elevation_end：终点海拔。 应用示例 LineString SELECT ST_AsTexT(ST_LocateBetweenElevations( ST_GeomFromText('LINESTRINGZ(1 2 3, 4 5 6)'), 2, 4)) As ewelev; ewelev ---------------------------------------------------------------- MULTILINESTRING Z ((1 2 3,2 3 4)) Polygon 从一个高程面中查询高程值2.5到3之间的面区域。 SELECT ST_AsText(the_geom) FROM ( SELECT ST_LocateBetweenElevations( ST_GeomFromtext('POLYGONZ((1 2 3, 1 4 2, 3 4 3,3 2 2,1 2 3))'), 2.5, 3) as the_geom) As foo; st_astext ----------------------------------------------------------------------- MULTIPOLYGON Z (((1 2 3,1 3 2.5,2 4 2.5,3 4 3,3 3 2.5,2 2 2.5,1 2 3))) "},"vector_function/LinearReferencing/ST_InterpolatePoint.html":{"url":"vector_function/LinearReferencing/ST_InterpolatePoint.html","title":"ST_InterpolatePoint","keywords":"","body":"ST_InterpolatePoint 方法功能描述 已知一个带M的LineString图形，及其任意点，通过插值计算返回该点对应的M值。 函数定义 float8 ST_InterpolatePoint(geometry line, geometry point); 参数定义： line:输入的一个带有高程值z的图形必须是LineStringM类型，其他图形类型还有高程z都不支持！！！ point：任意点，可以在线上或者不在线上。 返回值： 返回参数点对应的测量值。 应用示例 点在线上 SELECT ST_InterpolatePoint(st_geomfromtext('LINESTRING M (0 0 0, 10 0 20)'), st_geomfromtext('POINT(5 0)')); ST_InterpolatePoint -------------------------- 10 点不在线上 SELECT ST_InterpolatePoint(st_geomfromtext('LINESTRING M (0 0 0, 10 0 20)'), st_geomfromtext('POINT(5 5)')); ST_InterpolatePoint -------------------------- 10 说明：当点不在线上时，实际是先计算参数点到线上最近的点，然后使用最近的点计算测量值M，最后这个M值赋予参数点，结束。 "},"vector_function/LinearReferencing/ST_AddMeasure.html":{"url":"vector_function/LinearReferencing/ST_AddMeasure.html","title":"ST_AddMeasure","keywords":"","body":"ST_AddMeasure 方法功能描述 已知一条线，通过在起点设置一个测量值，终点设置一个测量值的方式，从而对线上任意位置线性插值了测量值。如果线图形没有测量值，将添加测量值，如果线图形已有测量值，将会被新计算后的测量值“替换”。 函数定义 geometry ST_AddMeasure(geometry geom_mline, float8 measure_start, float8 measure_end); 参数定义： geom_mline：对输入的线进行添加测量值操作，必须是LineString或MultiLinString类型。 measure_start:测量值起点，该值对应输入线的起点。 measure_end:测量值终点，该值对应输入线的终点。 返回值：LineStringM或MultiLinStringM带M值图形。 API示例 LineString SELECT ST_AsText(ST_AddMeasure( ST_GeomFromEWKT('LINESTRING(118 32, 119 32, 121 32)'),1,4)) As ewelev; ST_AsText ----------------------------------------- LINESTRING M (118 32 1,119 32 2,121 32 4) 结论：没有测量值，将会对线添加测量值。 LineStringM SELECT ST_AsText(ST_AddMeasure( ST_GeomFromEWKT('LINESTRINGM(118 32 7, 119 32 8, 121 32 10)'),1,4)) As ewelev; ST_AsText ----------------------------------------- LINESTRING M (118 32 1,119 32 2,121 32 4) 结论：已有测量值，将会用新测量值“替换”旧测量值。 MultiLineString SELECT ST_AsText(ST_AddMeasure( ST_GeomFromEWKT('MULTILINESTRING((118 32,119 32,121 32),(118 33, 119 33, 121 33))'),1,7)) As ewelev; 注意：第一个子线的最后一个点是(121 32 4)与第二个子线第一个点(118,33,4)，测量值都是4，这是什么原因？ 原理：ST_AddMeasure函数是把第二个子线的起点拼接到第一个子线的终点，那么可以121 32和118 33硬凑一起了。 那么第二条子线(118 33, 119 33, 121 33)就会变成(121 32,122 32,124 32)。 拼接到一起，然后计算测量值，然后再把测量值对应写会第二条子线上。 错误使用场景 新闻广播中常常有这样的报道：距离xx高速入口30公里处发生交通事故，这时地图上有个闪动的事故点，标明事故地点。为了实现这些功能，某技术人员对一条道路，其图形为线LineString(119 30,120.22 30.22,120.33 30.33)添加地理长度测量值，这条线起点（等同高速入口的意思）位置为0，终点设置为线的球面距离，这样，当计算某事故点距离起点多少米时，可以快速获取点的坐标位置。 第一步：计算线的真实长度： select ST_Length(ST_GeomFromText('LineString(119 30,120.22 30.22,120.33 30.33)',4326)::geography); ST_Length ------------------ 136231.99705736412 第二步：给线添加测量值： select ST_AsText(ST_AddMeasure( ST_GeomFromText('LineString(119 30,120.22 30.22,120.33 30.33)',4326),0,136231.99705736412)); st_astext ------------------------------------------------------------------------------------ LINESTRING M (119 30 0,120.22 30.22 121042.702052768,120.33 30.33 136231.997057364) 第三步：验证结果： 建立测量值后，[120.22 30.22]点处测量值M为121042.702052768。 计算起点线到[120.22 30.22]点真实球面距离为120085.05682156245。 select ST_Length(ST_GeomFromText('LineString(119 30,120.22 30.22)',4326)::geography); ST_Length ------------------ 120085.05682156245 ==技术人员结论：[120.22 30.22]测量值M与真实距离不一致。== 错误原因：终点处是通过geography类型计算的球面距离，但是ST_AddMeasure函数入参只能是geometry类型，导致球面距离线性插值到平面的geometry图形上，于是，在节点处导致测量值M与ST_Length不一致。 验证想法：线路长度使用平面长度，把平线长度的结果线性插值到平面线图形上： --平面geometry距离 select ST_Length(ST_GeomFromText('LineString(119 30,120.22 30.22,120.33 30.33)',4326)); ST_Length ------------------ 139524.0869245977 --平面距离，添加测量值 select ST_AsText(ST_AddMeasure( ST_GeomFromText('LineString(119 30,120.22 30.22,120.33 30.33)',4326),0,139524.0869245977)); st_astext ------------------------------------------------------------------------------------ LINESTRING M (119 30 0,120.22 30.22 123967.737738494,120.33 30.33 139524.086924598) --起点到[120.22 30.22]处的平面距离 select ST_Length(ST_GeomFromText('LineString(119 30,120.22 30.22)',4326)); ST_Length ------------------ 123967.737738494 结论：都统一使用平面距离后，线性插值的M值与实际计算的平面长度一致。因此，ST_AddMeasure不会导致计算结果出现差异，差异是平面球面理解不深，混合杂用导致计算维度不统一形成差异。 ==引申：然而平面距离的确不是球面距离，如果就是使用球面距离计算位置，如何计算？假设我们要求距离起点60000米（真实地理距离，球面距离）的位置点坐标。== --先计算整条线球面长度 select ST_Length(ST_GeomFromText('LineString(119 30,120.22 30.22,120.33 30.33)',4326)::geography); ST_Length ------------------ 136231.99705736412 --计算60000米占总长度的百分比。 select 60000/136231.99705736412 as per; per ---------------------- 0.44042516659823608027 --根据百分比定位 SELECT ST_AsText(ST_LineInterpolatePoint(ST_GeomFromText('LineString(119 30,120.22 30.22,120.33 30.33)',4326), 0.44042516659823608027)); ST_AsText --------------------------------------- POINT(119.604745257323 30.1090524234517) "},"vector_function/LinearReferencing/examples.html":{"url":"vector_function/LinearReferencing/examples.html","title":"综合案例","keywords":"","body":"背景 在对线性参考函数进行研究的时候，一直试图找一个综合点（系统点）的使用案例。但是很可惜在我以往的工程经验里面很少有使用到此类函数的场景，更为系统的使用就更加稀少。我也思考过这个问题，这个看起很高级的用法，但是使用的人很少呢？我想无外乎就是以下几点： 对数据的要求，线性参考避免对一个整体的数据进行切分保证的几何的连续性。但是几何数据是由测绘部门一段一段测绘得来，本身就是分开（不连续）。所以需要使用线性参考，就需要数据部门处理成合适的数据，这需要测绘与数据生产部门积极配合，这属于第一道坎。 开发人员大多数时候都只是响应产品经理或者业主的需求，而本质上线性参考是一种数据结构，是一种非常巧妙的数据结构。既然是数据结构，那就对产品经理或者业主是隔离的，他们是不知道这个东西的，他们思考的时候那就依然用熟悉的方式思考，这是第二道坎。 对于开发人员来说，线性参考使用的较少，积累的经验是不足的，对于系统的设计也是有挑战的。所以开发人员也会倾向于不使用该方法。 案例 场景描述 用线性参考描述高速公路里程的问题。 1、 纯几何 这种情况数据部门只提供一条几何线，所有里程全部是根据几何特性计算而来。这是最舒服的一个使用场景，完全是几何逻辑。而且计算结果和理论上的值是一样的，在这种情况是完全是没问题的。 with test_table as (select geom as line, ST_LineInterpolatePoint(geom,0.1) as point, st_length(geom::geography) as length from test_line) select ST_InterpolatePoint(ST_AddMeasure(line,0,length),point),length/10 from test_table ------- 17465.740134863605 | 17465.740134864067 2、 半几何 这种情况数据部门提供了一条几何线的同时，也提供了起点的里程，也就是这个里程不是从0开始。这种情况也是容易处理，只需要将ST_AddMeasure函数的输入给调整一下就OK。 with test_table as (select geom as line, ST_LineInterpolatePoint(geom,0.1) as point, st_length(geom::geography) as length,ST_LineInterpolatePoint(geom,0) as point0 ,ST_LineInterpolatePoint(geom,1) as point1 from test_line) select ST_InterpolatePoint(ST_AddMeasure(line,1000,length+1000),point),length/10,point from test_table 3、 非几何 这种情况数据部门提供了一条几何线的同时，也提供了这条线终止里程和开始里程。这里就会存在一个问题，数据部门提供了里程数据的误差是多少。这就好比要将一米赋给一条90CM的绳子，在绳子上的计算结果肯定是有误差的，而这个误差大小由开始里程与终止里程以及长度三个决定的，这个误差就不可控了。在这种情况，误差还会被总长度给平均掉，不会造成误差的叠加，还是能够接受的。 with test_table as (select geom as line, ST_LineInterpolatePoint(geom,0.1) as point, st_length(geom::geography) as length,ST_LineInterpolatePoint(geom,0) as point0 ,ST_LineInterpolatePoint(geom,1) as point1 from test_line) select ST_InterpolatePoint(ST_AddMeasure(line,1000,length+200+1000),point),length/10,point from test_table ------------ 18485.740134863605 | 17465.740134864067 4、纯业务 这种情况数据部门提供的是一条带M值的线，如果这个M值的准确的话，完全按照M值去计算还是符合业务的。但是我就遇到过这样的情况，对方提供的数据本身自带错误（误差几千米）。这就好比将1米赋给一个60里面的绳子，糟糕的是还要一直去纠结误差问题。而程序是基于数据是准确的（误差也在可接受范围），最终的计算结果差了很多也是可以能理解的。但是这个数据问题又是比较难找的，需要跨部门一个一个找过去。 with test_table as (select geom as line, ST_LineInterpolatePoint(geom,0.1) as point, st_length(geom::geography) as length,ST_LineInterpolatePoint(geom,0) as point0 ,ST_LineInterpolatePoint(geom,1) as point1 from test_line) select ST_InterpolatePoint(line,point),length/10,point from test_table --------- 39565.59199126357 | 17465.740134864067 总结 在上面的四个场景中，第四个场景是我真实碰见过的一个场景，而其他三个场景则是我为了找出问题所在做的几个实验。在做实验过程中，我还一度认为这是postgis的bug。还好最终定位出了问题，发现不是程序问题。但是把发现的问题抛出后，别的部门又是不认的。至于里面造成的原因，可能是坐标系弄错了，也有可能是软件操作错误。这里还把多个小段合并成长线的工作量给忽略掉了，所以真实的应用场景将会更加复杂。这就是为什么我们很少看到线性参考被真实的使用。我想碰到这样的情况，开发人员估计都会放弃这种数据结构，宁肯用更加繁琐操作。写这一小节的目的也是让使用线性参考的开发人员注意所带来的非技术问题，谨慎使用这个数据结构。 "}}