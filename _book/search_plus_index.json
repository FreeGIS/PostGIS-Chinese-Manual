{"./":{"url":"./","title":"Introduction","keywords":"","body":"PostGIS-Chinese-Manual PostGIS中文手册，富含大量实际案例和使用场景。 一 安装环境： 1.1 安装nodejs 1.2 全局安装gitbook npm install gitbook-cli -g 1.3 获取仓库并安装启动插件 git clone git@github.com:FreeGIS/PostGIS-Chinese-Manual.git cd PostGIS-Chinese-Manual gitbook install 1.4 启动项目 gitbook serve 页面预览地址：http://localhost:4000 "},"2-Installation/":{"url":"2-Installation/","title":"二 安装","keywords":"","body":"PostGIS-Chinese-Manual PostGIS中文手册，富含大量实际案例和使用场景。 一 安装环境： 1.1 安装nodejs 1.2 全局安装gitbook npm install gitbook-cli -g 1.3 获取仓库并安装启动插件 git clone git@github.com:FreeGIS/PostGIS-Chinese-Manual.git cd PostGIS-Chinese-Manual gitbook install 1.4 启动项目 gitbook serve 页面预览地址：http://localhost:4000 "},"2-Installation/0-PostgreSQL Installation.html":{"url":"2-Installation/0-PostgreSQL Installation.html","title":"2.1 PostgreSQL安装","keywords":"","body":"2.1 PostgreSQL安装 2.1.1 升级gcc 从镜像中下载较新的gcc压缩文件并解压： [root@ ~]# wget -c http://mirror.koddos.net/gcc/releases/gcc-9.2.0/gcc-9.2.0.tar.xz [root@ ~]# tar xvf gcc-9.2.0.tar.xz 下载并安装gcc依赖: [root@ ~]# cd gcc-9.2.0 [root@ gcc-9.2.0]# ./contrib/download_prerequisites 安装gcc，通过--prefix指定安装路径： [root@ gcc-9.2.0]# ./configure --prefix=/usr/local/gcc-9.2.0 --enable-checking=release --enable-languages=c,c++ --disable-multilib #服务器如果核数较多可以使用并行编译，比如有2核 # make -j 4 #-j后的并行数量应等于核数的2倍，不要太多。 [root@ gcc-9.2.0]# make -j 4 [root@ gcc-9.2.0]# make install 配置环境变量： [root@ gcc-9.2.0]# vi /etc/profile #将gcc加入path，注意path里有其他bin不要改，在后面追加，以免影响其他系统 export GCC_HOME=/usr/local/gcc-9.2.0 export PATH=$GDAL_HOME/bin:$GCC_HOME/bin:$PATH # :wq! 保存退出 #重启生效： [root@ gcc-9.2.0]# source /etc/profile 验证gcc安装： [root@ ~]# gcc --version gcc (GCC) 9.2.0 Copyright (C) 2019 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 移除低版本的yum安装的gcc，如果安装过将会卸载： [root@ ~]# yum remove gcc 更新系统库依赖，避免编译时发生glibcxx_x.x.xxx not found等lib包因版本差异导致的错误： #先全局查询libstdc++.so.6包所在位置 [root@ ~]# find / -name libstdc++.so.6 /usr/lib64/libstdc++.so.6 /usr/lib/libstdc++.so.6 /usr/local/gcc-9.2.0/lib64/libstdc++.so.6 #其中/usr/local是我们刚刚安装的，/lib与/lib64我们不清楚是不是残留，所以必须用新的直接替换即可。 [root@ ~]# cp /usr/local/gcc-9.2.0/lib64/libstdc++.so.6 /usr/lib [root@ ~]# cp /usr/local/gcc-9.2.0/lib64/libstdc++.so.6 /usr/lib64 2.1.2 其他依赖安装 [root@ ~]# yum install -y vim-enhanced.x86_64 gcc-java apr apr-devel openssl openssl-devel java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-devel.x86_64 perl-Module-Install.noarch readline-devel.x86_64 为了能在数据库中使用uuid，先要安装下uuid的库： # 下载uuid-1.6.2.tar.gz然后拷贝到安装服务器上。由于官方链接太烂，根本点不开，先暂时在百度网盘分享个资源： [uuid-1.6.2.tar.gz](https://pan.baidu.com/s/1NSHU8WrczfGDDsxYhEcAQQ) [root@ ~]# tar -zxvf uuid-1.6.2.tar.gz [root@ ~]# cd uuid-1.6.2 [root@ ~]# ./configure [root@ ~]# make [root@ ~]# make install 2.1.3 新建用户 [root@ ~]# useradd postgres 2.1.4 下载PG12源码编译安装 [root@ ~]# wget https://ftp.postgresql.org/pub/source/v12.1/postgresql-12.1.tar.gz [root@ ~]# tar -zxvf postgresql-12.1.tar.gz [root@ ~]# cd postgresql-12.1 [root@ postgresql-12.1]# ./configure --prefix=/home/postgres --enable-thread-safety --with-uuid=ossp --with-libs=/usr/local/lib --with-includes=/usr/local/include [root@ postgresql-12.1]# make -j 4 [root@ postgresql-12.1]# make install # 安装contrib工具包 [root@ postgresql-12.1]# cd contrib [root@ contrib]# make [root@ contrib]# make install 2.1.5 权限设置 #把程序安装目录全部赋权给postgres用户 [root@ contrib]# chown -R postgres.postgres /home/postgres/ 2.1.6 配置postgres用户环境变量 [root@ contrib]# su - postgres [postgres@ ~]$ vi .bashrc #编辑内容如下： PGHOME=/home/postgres export PGHOME PGDATA=$PGHOME/data export PGDATA PATH=$PATH:$HOME/.local/bin:$HOME/bin:$PGHOME/bin export PATH # wq! 保存退出 #重启生效 [postgres@ ~]$ source .bashrc 2.1.7 数据库初始化与启动 [postgres@ ~]$ initdb -D $PGDATA [postgres@ ~]$ pg_ctl start -D $PGDATA #登录数据库 [postgres@ ~]$ psql psql (12.1) Type \"help\" for help. postgres=# 到此为止，数据库已经完成安装，但只能本机连接，性能参数配置是默认的。有时候希望其他客户端也能连接，需要设置$PGDATA中的pg_hba.conf与postgresql.conf中相关参数，这些内容可以详细查看其他PG相关的博客和书籍。 "},"2-Installation/1-PostGIS Installation.html":{"url":"2-Installation/1-PostGIS Installation.html","title":"2.2 PostGIS安装","keywords":"","body":"2.2 PostGIS安装 本教程安装PostGIS 3.0,3.0依赖的库有geos,proj,gdal,libxml,json-c,protobuf，如何要支持三维需安装sfcgal，如果要做路网分析需安装pgrouting。 2.2.1 安装依赖 2.2.1.1 geos [root@ ~]# wget https://download.osgeo.org/geos/geos-3.8.0.tar.bz2 [root@ ~]# tar -jxvf geos-3.8.0.tar.bz2 [root@ ~]# cd geos-3.8.0 #指定目录安装 [root@ geos-3.8.0]# ./configure --prefix=/usr/local/geos-3.8.0 [root@ geos-3.8.0]# make -j 4 [root@ geos-3.8.0]# make install 2.2.1.2 proj [root@ ~]# wget http://download.osgeo.org/proj/proj-6.2.1.tar.gz [root@ ~]# tar -zxvf proj-6.2.1.tar.gz [root@ ~]# cd proj-6.2.1 #指定目录安装 [root@ proj-6.2.1]# ./configure --prefix=/usr/local/proj-6.2.1 [root@ proj-6.2.1]# make -j 4 [root@ proj-6.2.1]# make install 2.2.1.3 gdal [root@ ~]# wget https://download.osgeo.org/gdal/3.0.2/gdal-3.0.2.tar.gz [root@ ~]# tar -zxvf gdal-3.0.2.tar.gz [root@ ~]# cd gdal-3.0.2 #编译时间比较久，指定目录安装，且绑定已安装的pg [root@ gdal-3.0.2]# ./configure --prefix=/usr/local/gdal-3.0.2 --with-pg=/home/postgres/bin/pg_config [root@ gdal-3.0.2]# make -j 4 [root@ gdal-3.0.2]# make install 2.2.1.4 jsonc,libxml [root@ ~]# wget https://github.com/json-c/json-c/archive/json-c-0.13.1-20180305.tar.gz [root@ ~]# tar -zxvf json-c-0.13.1-20180305.tar.gz [root@ ~]# cd json-c-0.13.1-20180305 [root@ json-c-0.13.1-20180305]# ./configure --prefix=/usr/local/json-c-0.13.1 [root@ json-c-0.13.1-20180305]# make -j 4 [root@ json-c-0.13.1-20180305]# make install [root@ ~]# wget https://github.com/GNOME/libxml2/archive/v2.9.7.tar.gz [root@ ~]# tar -zxvf libxml2-sources-2.9.7.tar.gz [root@ ~]# cd libxml2-2.9.7 [root@ libxml2-2.9.7]# ./configure --prefix=/usr/local/libxml2-2.9.7 [root@ libxml2-2.9.7]# make -j 4 [root@ libxml2-2.9.7]# make install 2.2.1.5 protobuf,protobuf-c [root@ ~]# wget https://github.com/protocolbuffers/protobuf/archive/v3.10.1.tar.gz [root@ ~]# tar -zxvf protobuf-3.10.1.tar.gz [root@ ~]# cd protobuf-3.10.1 [root@ protobuf-3.10.1]# ./configure --prefix=/usr/local/protobuf-3.10.1 [root@ protobuf-3.10.1]# make -j 4 [root@ protobuf-3.10.1]# make install #配置环境变量，增加下protobuf-3.10.1/bin [root@ ~]# vi /etc/profile export PROTOBUF_HOME=/usr/local/protobuf-3.10.1 export PATH=$GCC_HOME/bin:$PROTOBUF_HOME/bin:$PATH #保存退出 [root@ ~]# source /etc/profile #验证protobuf执行程序 [root@ ~]# protoc --version libprotoc 3.10.1 #protobuf安装成功 [root@ ~]# wget https://github.com/protobuf-c/protobuf-c/releases/download/v1.3.2/protobuf-c-1.3.2.tar.gz [root@ ~]# tar -zxvf protobuf-c-1.3.2.tar.gz [root@ ~]# cd protobuf-c-1.3.2 #导入protobuf的pkgconfig，否则\"--No package 'protobuf' found\" [root@ protobuf-c-1.3.2]# export PKG_CONFIG_PATH=/usr/local/protobuf-3.10.1/lib/pkgconfig [root@ protobuf-c-1.3.2]# ./configure --prefix=/usr/local/protobuf-c-1.3.2 [root@ protobuf-c-1.3.2]# make -j 4 [root@ protobuf-c-1.3.2]# make install #配置环境变量，增加下protobuf-c-1.3.2/bin [root@ ~]# vi /etc/profile export PROTOBUF_HOME=/usr/local/protobuf-3.10.1 export PROTOBUFC_HOME=/usr/local/protobuf-c-1.3.2 export PATH=$GCC_HOME/bin:$PROTOBUF_HOME/bin:$PROTOBUFC_HOME/bin:$PATH #保存退出 [root@ ~]# source /etc/profile 2.2.1.6 sfcgal (三维场景，可选择安装) sfcgal需要cmkae编译，需先安装下cmake： [root@ ~]# wget https://github.com/Kitware/CMake/releases/download/v3.16.2/cmake-3.16.2.tar.gz [root@ ~]# tar -zxvf cmake-3.16.2.tar.gz [root@ ~]# cd cmake-3.16.2 [root@ cmake-3.16.2]# ./configure --prefix=/usr/local/cmake-3.16.2 [root@ cmake-3.16.2]# make -j 4 [root@ cmake-3.16.2]# make install #配置环境变量 [root@ ~]# vi /etc/profile export CMAKE_HOME=cmake-3.16.2 export PATH=$GCC_HOME/bin:$CMAKE_HOME/bin:$PROTOBUF_HOME/bin:$PROTOBUFC_HOME/bin:$PATH #保存退出 [root@ ~]# source /etc/profile sfcgal依赖boost,cgal，需要提前编译，编译默认目录，避免编译sfcgal时各种找不到库的问题。 [root@ ~]# yum install boost-devel [root@ ~]# wget https://github.com/CGAL/cgal/archive/releases/CGAL-4.13.tar.gz [root@ ~]# tar -zxvf CGAL-4.13.tar.gz [root@ ~]# cd CGAL-4.13 [root@ CGAL-4.13]# mkdir build && cd build #cmake不要指定安装路径 [root@ build]# cmake .. [root@ build]# make [root@ build]# make install 编译安装sfcgal： [root@ ~]# wget https://github.com/Oslandia/SFCGAL/archive/v1.3.7.tar.gz [root@ ~]# tar -zxvf v1.3.7.tar.gz [root@ ~]# cd SFCGAL-1.3.7 [root@ SFCGAL-1.3.7]# mkdir build & cd build [root@ build]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/sfcgal-1.3.7 .. [root@ build]# make -j 4 [root@ build]# make install pgrouting可以单独安装，在之后章目里会单独介绍。 2.2.2 PostGIS安装 2.2.2.1 配置ld.so.conf [root@ ~]# vim /etc/ld.so.conf #编辑内容如下 include ld.so.conf.d/*.conf /home/postgres/lib /usr/local/proj-6.2.1/lib /usr/local/gdal-3.0.2/lib /usr/local/geos-3.8.0/lib /usr/local//sfcgal-1.3.7/lib64 /usr/local/json-c-0.13.1/lib /usr/local/libxml2-2.9.7/lib /usr/local/protobuf-3.10.1/lib /usr/local/protobuf-c-1.3.2/lib #编辑完成后wq!保存退出 #保存配置，重启生效 [root@ ~]# ldconfig -v 2.2.2.2 安装postgis [root@ ~]# wget http://download.osgeo.org/postgis/source/postgis-3.0.0.tar.gz [root@ ~]# tar -zxvf postgis-3.0.0.tar.gz [root@ ~]# cd postgis-3.0.0 #根据安装不同的要求，选择任意一个configure #基本安装，不带sfcgal [root@ postgis-3.0.0]# ./configure --prefix=/home/postgres --with-gdalconfig=/usr/local/gdal-3.0.2/bin/gdal-config --with-pgconfig=/home/postgres/bin/pg_config --with-geosconfig=/usr/local/geos-3.8.0/bin/geos-config --with-projdir=/usr/local/proj-6.2.1 --with-xml2config=/usr/local/libxml2-2.9.7/bin/xml2-config --with-jsondir=/usr/local/json-c-0.13.1 --with-protobufdir=/usr/local/protobuf-c-1.3.2 # 带protobuf,sfcgal安装 [root@ postgis-3.0.0]# ./configure --prefix=/home/postgres --with-gdalconfig=/usr/local/gdal-3.0.2/bin/gdal-config --with-pgconfig=/home/postgres/bin/pg_config --with-geosconfig=/usr/local/geos-3.8.0/bin/geos-config --with-projdir=/usr/local/proj-6.2.1 --with-xml2config=/usr/local/libxml2-2.9.7/bin/xml2-config --with-jsondir=/usr/local/json-c-0.13.1 --with-protobufdir=/usr/local/protobuf-c-1.3.2 --with-sfcgal=/usr/local/sfcgal-1.3.7/bin/sfcgal-config [root@ postgis-3.0.0]# make -j 4 [root@ postgis-3.0.0]# make install 可能报错什么can not found lsqlite3等错误： yum instlal sqlite-devel 2.2.2.3 验证安装 [root@ ~]# su - postgres [postgres@ ~]$ psql psql (12.1) Type \"help\" for help. postgres=# create database mytest; CREATE DATABASE postgres=# \\c mytest You are now connected to database \"mytest\" as user \"postgres\". #验证postgis扩展 mytest=# create extension postgis; CREATE EXTENSION #验证栅格类数据需要的raster扩展 mytest=# create extension postgis_raster; CREATE EXTENSION #如果安装带有sfcgal，验证下三维sfcgal扩展 mytest=# create extension postgis_sfcgal; CREATE EXTENSION "},"8-VectorFunction/":{"url":"8-VectorFunction/","title":"八 矢量函数","keywords":"","body":"PostGIS-Chinese-Manual PostGIS中文手册，富含大量实际案例和使用场景。 一 安装环境： 1.1 安装nodejs 1.2 全局安装gitbook npm install gitbook-cli -g 1.3 获取仓库并安装启动插件 git clone git@github.com:FreeGIS/PostGIS-Chinese-Manual.git cd PostGIS-Chinese-Manual gitbook install 1.4 启动项目 gitbook serve 页面预览地址：http://localhost:4000 "},"8-VectorFunction/3-GeometryAccessors.html":{"url":"8-VectorFunction/3-GeometryAccessors.html","title":"8.4 元数据读写","keywords":"","body":"8.4 元数据读写 以下函数返回图形类型和图形类型对应的坐标和拓扑维度。 GeometryType 作用：返回图形类型字符串，字符串形式是：'POINT','LINESTRING','POLYGON','MULTIPOINT','MULTILINESTRING','MULTIPOLYGON'等等。 SELECT GeometryType(ST_GeomFromText('Point(118 32)')); geometrytype ------------------- POINT SELECT GeometryType(ST_GeomFromText('LineString(118 32,119 33)')); geometrytype ------------------- LINESTRING ST_GeometryType 作用：返回图形类型SQL_MM字符串，字符串形式是：'ST_Point','ST_Linestring','ST_Polygon','ST_MultiPoint','ST_MultiLinestring','ST_MultiPolygon'等等。 SELECT ST_GeometryType(ST_GeomFromText('Point(118 32)')); st_geometrytype ------------------- ST_Point SELECT ST_GeometryType(ST_GeomFromText('LineString(118 32,119 33)')); st_geometrytype ------------------- ST_Linestring ST_CoordDim/ST_NDims 作用：两个函数一模一样，都是返回图形坐标维度，如二维返回2，xyz,xym都返回3，xyzm返回4。 坐标形式 维度 xy 2 xyz 3 xym 3 xyzm 4 --xy SELECT ST_CoordDim(ST_GeomFromText('Point(1 2)')); st_coorddim ------------- 2 --xyz SELECT ST_CoordDim(ST_GeomFromText('PointZ(1 2 3')); st_coorddim ------------- 3 --xym SELECT ST_CoordDim(ST_GeomFromText('PointM(1 2 3')); st_coorddim ------------- 3 --xyzm SELECT ST_CoordDim(ST_GeomFromText('PointZM(1 2 2 2')); st_coorddim ------------- 4 ST_Dimension 作用：返回图形的拓扑维度，拓扑维度只区分大类，如POINT形式，子形式包括MULTIPOINT,POINTZ,POINTM,POINTZM，统统都返回0，以此类推。 几何拓扑形式 | 维度 ---|--- POINT | 0 LINESTRING | 1 POLYGON | 2 EMPTY | -1 --xy点 SELECT ST_CoordDim(ST_GeomFromText('Point(1 2)')); ST_Dimension ------------- 0 --multi点 SELECT ST_CoordDim(ST_GeomFromText('MultiPoint(1 2,3 4)')); ST_Dimension ------------- 0 --xyz点 SELECT ST_CoordDim(ST_GeomFromText('PointZ(1 2 3')); ST_Dimension ------------- 0 --xym点 SELECT ST_CoordDim(ST_GeomFromText('PointM(1 2 3')); ST_Dimension ------------- 0 --xyzm点 SELECT ST_CoordDim(ST_GeomFromText('PointZM(1 2 2 2')); ST_Dimension ------------- 0 --linestring SELECT ST_CoordDim(ST_GeomFromText('LineString(1 2,3 4)')); ST_Dimension ------------- 1 --polygon SELECT ST_CoordDim(ST_GeomFromText('Polygon((0 0,0 1,1 1,1 0,0 0))')); ST_Dimension ------------- 2 对于类型不明确的，如GEOMETRYCOLLECTION，会选择集合里维度最高的子图形，将该子图形的图形拓扑维度返回： SELECT ST_Dimension('GEOMETRYCOLLECTION(LINESTRING(1 1,0 0),POINT(0 0))'); ST_Dimension ----------- 1 SELECT ST_Dimension('GEOMETRYCOLLECTION(Polygon((0 0,0 1,1 1,1 0,0 0)),LINESTRING(1 1,0 0),POINT(0 0))'); ST_Dimension ----------- 2 ST_Zmflag 作用：该函数主要用于测试一个图形的坐标究竟是带m还是带z值，根据其不同转态返回能提现zm状态的维度编码。 zm坐标形式 | 维度 ---|--- xy | 0 xym | 1 xyz | 2 xyzm | 3 ST_Zmflag与ST_CoordDim,ST_NDims不同，ST_CoordDim,ST_NDims中，xyz与xym都返回3，xyzm返回4，这两个函数返回值只是表达了图形坐标是几维构成，但是同样是三维，究竟是xyz还是xym是区分不了的。而通过ST_Zmflag函数，能得到准确的图形坐标究竟是xyz还是xym形式。 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRING(1 2, 3 4)')); st_zmflag ----------- 0 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGM(1 2 0, 3 4 0)')); st_zmflag ----------- 1 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGZ(1 2 0, 3 4 0)')); st_zmflag ----------- 2 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGZM(1 2 0 0, 3 4 0 0)')); st_zmflag ----------- 3 --对比下ST_CoordDim,ST_NDims SELECT ST_CoordDim(ST_GeomFromEWKT('LINESTRINGZ(1 2 0, 3 4 0)')); ST_CoordDim ----------- 3 SELECT ST_CoordDim(ST_GeomFromEWKT('LINESTRINGM(1 2 0, 3 4 0)')); ST_CoordDim ----------- 3 --ST_CoordDim,ST_NDims无法区分第三维究竟是z还是m。 以下函数为测试函数，判别geometry某个属性是否具备某个状态。 ST_HasArc 作用：该函数主要用于测试一个图形是否包含圆弧。判断依据比较勉强，仅仅判断图形或者图形集合中的子图形是不是包含圆弧标志的字符串。 下例以CIRCULARSTRING(1 1, 2 2, 3 3, 4 4, 5 5)说明，这个圆弧长什么样都不知道，但是只要用CIRCULARSTRING声明其是圆弧，就会返回true。圆弧在PostGIS中其实能构造但是其他可视化软件不认识，无法可视化。该函数使用频率其实也非常低。 SELECT ST_HasArc(ST_GeomFromEWKT('CIRCULARSTRING(1 1, 2 2, 3 3, 4 4, 5 5)')); st_hasarc -------- true ST_IsPolygonCCW 作用：测试多边形是否具有逆时针方向的外环和顺时针方向的内环。 --外环是逆时针方向，内环是顺时针方向 select ST_IsPolygonCCW(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))')); ST_IsPolygonCCW ------------------- true --外环是逆时针方向，内环也是逆时针方向 select ST_IsPolygonCCW(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,2 1,2 2,1 2,1 1))')); ST_IsPolygonCCW ------------------- false ST_IsPolygonCW 作用：测试多边形是否具有顺时针方向的外环和逆时针方向的内环。 select ST_IsPolygonCW(ST_GeomFromEWKT('Polygon((0 0,0 3,3 3,3 0,0 0),(1 1,2 1,2 2,1 2,1 1))')); ST_IsPolygonCW ------------------- true ST_IsClosed 作用：判别一个线是否闭合。Polygon一定是闭合的否则构造会出错，因此，该函数常用就是判别线。所谓闭合，就是起点=终点 ，即首尾相连。 主要使用场景： SELECT ST_IsClosed(ST_GeomFromEWKT('LINESTRING(0 0, 1 1)')); st_isclosed ------------- false SELECT ST_IsClosed(ST_GeomFromEWKT('LINESTRING(0 0, 1 1,1 0,0 0)')); st_isclosed ------------- true 以下场景不常用，但是该函数也支持，并且返回结果有点差异。 多义线，每个子线都是首尾相连的： SELECT ST_IsClosed(ST_GeomFromEWKT('MULTILINESTRING((0 0, 1 1,1 0,0 0),(3 3,4 4,4 3,3 3))')); st_isclosed ------------- true 多义线，至少有个子线不是首尾相连的： SELECT ST_IsClosed(ST_GeomFromEWKT('MULTILINESTRING((0 0, 1 1,1 0,0 0),(3 3,4 4,4 3,3.5 3))')); st_isclosed ------------- true 结论：多义线实际是计算每个子线是否闭合，只有所有子线都闭合，才返回true，任意一个子线不闭合，就会返回false。 根据闭合的概念 起点=终点 那么对于点而言，起点终点就是一个点，所以一定返回true；而多义点和多义线一样，是分别计算每个子图形是否闭合，由于MultiPoint的子图形都是Point，而Point一定返回true，那么意味着于MultiPoint的子图形都是闭合的。 SELECT ST_IsClosed('POINT(0 0)'::geometry); st_isclosed ------------- true SELECT ST_IsClosed('MULTIPOINT((0 0), (1 1))'::geometry); st_isclosed ------------- true 结论： 1 对于点，多义点，该函数总是返回true。 2 对于线首尾相连认定闭合，多义线要保证每个子线都是闭合才认为多义线闭合。 3 对于面，多义面，由于面一定是闭合的，因此该函数总是返回true。 4 该函数其实仅仅用于判定LineString是否闭合为主要目的。 ST_IsCollection 作用：判定一个图形是否是集合类型，集合类型列表如下： • GEOMETRYCOLLECTION • MULTI{POINT,POLYGON,LINESTRING,CURVE,SURFACE} • COMPOUNDCURVE 当图形类型为列表类型时，该函数返回true，否则返回false。 --单线 SELECT ST_IsCollection('LINESTRING(0 0, 1 1)'::geometry); st_iscollection ------------- false --多义线 SELECT ST_IsCollection('MultiLINESTRING((0 0, 1 1))'::geometry); st_iscollection ------------- true ST_IsEmpty 作用：判定一个图形是否为空。 SELECT ST_IsEmpty(ST_GeomFromText('POLYGON EMPTY')); st_isempty ------------ true SELECT ST_IsEmpty(ST_GeomFromText('POLYGON((1 2, 3 4, 5 6, 1 2))')); st_isempty ------------ false ST_IsRing 作用：判定是否为“环”，图形中的换“环”其实是闭合的单线，比如Polygon就是一个个环组成的图形。对于“环”的定义应满足如下两点： 1 闭合的线，则ST_IsClosed(geom)=true。 2 该线不自相交，不自相切，则ST_IsSimple(geom)=true。 ​ SELECT ST_IsRing(geom), ST_IsClosed(geom), ST_IsSimple(geom) FROM (SELECT 'LINESTRING(0 0, 0 1, 1 1, 1 0, 0 0)'::geometry AS geom) AS foo; st_isring | st_isclosed | st_issimple -----------+-------------+------------- true | true | true SELECT ST_IsRing(geom), ST_IsClosed(geom), ST_IsSimple(geom) FROM (SELECT 'LINESTRING(0 0, 0 1, 1 0, 1 1, 0 0)'::geometry AS geom) AS foo; st_isring | st_isclosed | st_issimple -----------+-------------+------------- false | true | false 结论：由“环”定义可知，只有当则ST_IsClosed与则ST_IsSimple两个函数都返回true，ST_IsRing(geom)才会返回true。 ST_IsSimple 作用：判定一个图形是否自相交或者自相切。 示意图见ST_IsRing中示意图。 SELECT ST_IsSimple('LINESTRING(0 0, 0 1, 1 1, 1 0, 0 0)'::geometry); st_issimple ------------- true SELECT ST_IsSimple('LINESTRING(0 0, 0 1, 1 0, 1 1, 0 0)'::geometry); st_issimple ------------- false 以上函数为测试函数，判别geometry某个属性是否具备某个状态。 ST_Boundary 作用：返回图形边界，抽象，用例子说明。 1 对于点而言，图形边界都是empty： SELECT ST_AsText(ST_Boundary('Point(1 1)'::geometry)); st_astext ------------------------ GEOMETRYCOLLECTION EMPTY SELECT ST_AsText(ST_Boundary('MultiPoint(1 1,2 2)'::geometry)); st_astext ------------------------- GEOMETRYCOLLECTION EMPTY 2 对于未闭合线而言，图形边界是其起点和终点： SELECT ST_AsText(ST_Boundary('LINESTRING(1 1,2 2,3 -1)'::geometry)); st_astext ------------------------- MULTIPOINT(1 1,3 -1) SELECT ST_AsText(ST_Boundary('MultiLINESTRING((1 1,2 2,3 -1),(0 0,-1 -1,-2 3))'::geometry)); st_astext ------------------------------ MULTIPOINT(1 1,3 -1,0 0,-2 3) 补充：对MultiLINESTRING而言，分别计算子线的边界（起点，终点），然后把所有子线的边界（都是点）塞到一个MULTIPOINT返回。 3 对于闭合线，图形边界为空： SELECT ST_AsText(ST_Boundary('LINESTRING(1 1,2 2,3 -1,1 1)'::geometry)); st_astext ------------------------ MULTIPOINT EMPTY 4 对于面而言，图形边界是其环： 单义面： select ST_AsText(ST_Boundary(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))'))); st_astext ------------------------------------------------------------ MULTILINESTRING((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)) 多义面： select ST_AsText(ST_Boundary( ST_GeomFromEWKT('MultiPolygon(((0 0,1 0,1 1,0 1,0 0)),((2 2,2 3,3 3,3 2,2 2)))'))); st_astext ------------------------------------------------------------ MULTILINESTRING((0 0,1 0,1 1,0 1,0 0),(2 2,2 3,3 3,3 2,2 2)) ST_Envelope 作用：返回一个图形的外接矩形。点的外接矩形是Point，线面的外接矩形是个长方形Polygon，xyz的线面外接矩形仍然是xy维度里的长方形，而非官方手册说的长方体。 --点 SELECT ST_AsText(ST_Envelope('POINT(1 3)'::geometry)); st_astext ------------ POINT(1 3) --线 SELECT ST_AsText(ST_Envelope('LineString(0 0,1 1)'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) --面 SELECT ST_AsText(ST_Envelope('Polygon((0 0,1 0,1 1,0 1,0 0))'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) --xyz 线 SELECT ST_AsText(ST_Envelope('LineStringZ(0 0 0,1 1 1)'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) --xyz面 SELECT ST_AsText(ST_Envelope('PolygonZ((0 0 0,1 0 1,1 1 1,0 1 0,0 0 0))'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) 说明：xyz的线面返回还是二维的xy面，z轴被丢失了。 ST_Envelope与Box2D 相同点：ST_Envelope与Box2D都是获取输入图形的外接矩形。 不同点：ST_Envelope返回的是个geometry对象，如'Polygon((minx miny,minx maxy,maxx maxy,maxx miny,minx miny))::geometry'；Box2D返回的是box2d对象，如BOX(minx,miny,maxx,maxy)。 ST_BoundingDiagonal 作用：返回一个图形边界框构成的对角线。该函数会保留所有的srid和zm维度。 函数定义：ST_BoundingDiagonal(geometry geom, boolean fits=false) 参数说明：fits参数表示是否采用最佳拟合，在输入图形节点很多的情况下，fits=true则获取的边界框构成的对角线更精确点，但是稍慢；fits=false则获取的边界框范围稍大，但是速度更快。fits无论true或false，对角线构成的边界框都会覆盖输入图形（对角线的bbox>=输入图形的bbox） --xy SELECT ST_AsText(ST_BoundingDiagonal('Polygon((0 0,1 0,1 1,0 1,0 0))'::geometry)); st_astext --------------------------- LINESTRING(0 0,1 1) --xyz SELECT ST_AsText(ST_BoundingDiagonal('PolygonZ((0 0 0,1 0 1,1 1 1,0 1 0,0 0 0))'::geometry)); st_astext --------------------------- LINESTRING Z (0 0 0,1 1 1) ST_X,ST_Y,ST_Z,ST_M 作用：ST_X,ST_Y,ST_Z,ST_M四个函数分别返回Point的x，y，z，m值，入参必须是Point。 SELECT ST_X(geom), ST_Y(geom), ST_Z(geom),ST_M(geom) FROM (SELECT ST_GeomFromEWKT('POINT(1 2 3 4)') AS geom) AS foo; st_x | st_y | st_z | st_m -------------------------- 1 | 2 | 3 | 4 ST_StartPoint,ST_EndPoint 作用：ST_StartPoint,ST_EndPoint分别返回LineString或CircularLineString的起点，终点，入参必须是LineString与CircularLineString，如果是其他图形类型，返回null。 SELECT ST_AsText(ST_StartPoint(geom)) startpt, ST_AsText(ST_EndPoint(geom)) endpt FROM (SELECT ST_GeomFromEWKT('LINESTRING(0 0, 0 1, 1 0, 1 1)') AS geom) AS foo; startpt | endpt -------------------------- POINT(0 0) | POINT(1 1) SELECT ST_EndPoint('POINT(1 1)'::geometry) IS NULL AS is_null; is_null -------- true ST_NumGeometries,ST_GeometryN 作用：ST_NumGeometries返回一个图形集合中子图形的数量，ST_GeometryN返回图形集合中序号为n的子图形。两者关系类似与其他语言中获取数组的长度，根据索引返回数组中指定子项。 图形集合的概念：GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON, POLYHEDRALSURFACE。 索引序号：数据库中数组首项序号是1。与其他语言中数组首项序号为0有区别。 --获取图形集合中的子图形数量。 SELECT ST_NumGeometries(ST_GeomFromEWKT('GEOMETRYCOLLECTION( POINT(0 0), LINESTRING(0 0,1 1), POLYGON((0 0,1 0,1 1,0 1,0 0)))')); ST_NumGeometries --------------------------- 3 --获取图形集合中序号为2的子图形 SELECT ST_AsText(ST_GeometryN(ST_GeomFromEWKT('GEOMETRYCOLLECTION( POINT(0 0), LINESTRING(0 0,1 1), POLYGON((0 0,1 0,1 1,0 1,0 0)))'),2)); ST_GeometryN --------------------------- LINESTRING(0 0,1 1) --Multi类型 SELECT ST_NumGeometries(ST_GeomFromEWKT('MultiPOINT(0 0,1 1,2 2)')); ST_NumGeometries --------------------------- 3 SELECT ST_AsText(ST_GeometryN(ST_GeomFromEWKT('MultiPOINT(0 0,1 1,2 2)'),2)); ST_GeometryN --------------------------- POINT(1 1) ST_NRings,ST_ExteriorRing,ST_NumInteriorRings,ST_NumInteriorRing,ST_InteriorRingN 函数名称 作用 ST_NRings 返回Polygon的“环”数量，包括外环和内环 ST_NumInteriorRings 返回Polygon的“内环”数量 ST_NumInteriorRing 与ST_NumInteriorRings一模一样 ST_ExteriorRing 获取Polygon的外环(Polygon只有一个外环) ST_InteriorRingN 获取Polygon的指定序号的内环(Polygon可以有多个内环) 所谓“内环”就是面内组成孔洞的闭合线（孔洞边界线）。 限制说明：不用多想，只要记住这些函数仅支持Polygon类型。 --无孔洞 --该面就只有1个外环，内环数量0 SELECT ST_NRings(geom),ST_NumInteriorRings(geom) from (SELECT ST_GeomFromEWKT('Polygon((0 0,1 0,1 1,0 1,0 0))') AS geom) AS foo; ST_NRings | ST_NumInteriorRings -------------------------------------- 1 | 0 --有孔洞 --返回孔洞数量 SELECT ST_NRings(geom),ST_NumInteriorRings(geom) from (SELECT ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))') AS geom) AS foo; ST_NRings | ST_NumInteriorRings -------------------------------------- 2 | 1 --获取外环的图形 SELECT ST_AsText(ST_ExteriorRing(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))'))); ST_AsText ------------------------------- LINESTRING(0 0,3 0,3 3,0 3,0 0) --获取第一个孔洞的图形 SELECT ST_AsText(ST_InteriorRingN(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))'),1)); ST_AsText ------------------------------- LINESTRING(1 1,1 2,2 2,2 1,1 1) ST_NRings是支持MultiPolygon的： SELECT ST_NRings(ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)))')); ST_NRings ------------ 2 PostGIS官网说ST_NumInteriorRings支持MultiPolygon，返回MultiPolygon的第一个Polygon中的内环数量，但实测发现官网是错误的，ST_NumInteriorRings对MultiPolygon返回了null： SELECT ST_NumInteriorRings(ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)))')); ST_NumInteriorRings -------------------- null 结论：除ST_NRings支持MultiPolygon外，原则上这些函数都认为是只处理Polygon类型比较好，实际也的确只是用来处理Polygon的。 ST_NumPatches,ST_PatchN 函数名称 作用 ST_NumPatches 返回多面曲面上面的数量，对非多面曲面类型返回null ST_PatchN 返回多面曲面上指定序号为n的曲面，使用ST_GeometryN可以替代ST_PatchN，结果一样且查询更快 --返回曲面多面上面的数量 SELECT ST_NumPatches(ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )')); ST_NumPatches ------------ 6 --返回曲面多面上指定序号为n的曲面 SELECT ST_AsEWKT(ST_PatchN(geom, 2)) FROM (VALUES (ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )' )) ) As foo(geom); ST_AsEWKT ----------------------------------------- POLYGON((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0)) --其实使用ST_GeometryN可以替代ST_PatchN，结果一样。 ST_NPoints,ST_NumPoints,ST_PointN,ST_Points 函数名称 作用 ST_NPoints 返回geometry上Point点数量，不仅仅针对LineString。 ST_NumPoints 返回LineString或CircularString上节点数量，不支持Multi类型。 ST_PointN 返回LineString或CircularString指定序号为n的点，n=-1是终点。 ST_Points 返回geometry上所有Point点坐标，结果为MultiPoint形式。 --ST_NPoints SELECT ST_NPoints(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)')); ST_NPoints -------------- 3 SELECT ST_NPoints(ST_GeomFromText('Polygon((1 1,1 2,2 2,2 1,1 1))')); ST_NPoints -------------- 5 --ST_NumPoints SELECT ST_NumPoints(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)')); ST_NumPoints -------------- 3 SELECT ST_NumPoints(ST_GeomFromText('Polygon((1 1,1 2,2 2,2 1,1 1))')); ST_NumPoints -------------- null --序号为2 SELECT ST_AsText(ST_PointN(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'),2)); ST_AsText -------------- POINT(2 2) --序号为0 SELECT ST_AsText(ST_PointN(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'),0)); ST_AsText -------------- null --序号为-1 SELECT ST_AsText(ST_PointN(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'),-1)); ST_AsText -------------- POINT(3 4) --ST_Points select ST_AsText(ST_Points(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'))); ST_AsText ----------------------- MULTIPOINT(1 1,2 2,3 4) select ST_AsText(ST_Points(ST_GeomFromText('Polygon((1 1,1 2,2 2,2 1,1 1))'))); ST_AsText ------------------------------- MULTIPOINT(1 1,1 2,2 2,2 1,1 1) 结论：ST_NPoints和ST_NumPoints相同点是都获取图形的Point点数量；不同点是ST_NumPoints仅仅针对LineString或CircularString，而ST_NPoints还支持更多其他类型的图形。 ST_MemSize 作用：返回一个geom占用内存空间大小。 说明：ST_MemSize是PostgreSQL原生的pg_column_size, pg_size_pretty, pg_relation_size, pg_total_relatio_size等获取表或字段物理大小字段的补充，原因是原生函数不能准确表达geom的大小。 为什么不使用原生的pg函数去获取geometry或geom列或空间表的物理大小？由于geometry是个大对象，PG中对于大对象的物理存储提供了TOAST功能，只有了解TOAST的四种存储策略，才能理解为什么原生函数不适合，而要引入ST_MemSize，关于TOAS与PostGIS更多知识，请查看：待补充。 --单位是bytes，如果对象特别大，可以用pg_size_pretty函数显示的更人性化 --pg_size_pretty可以根据实际大小返回MB，GB等单位。 select ST_MemSize(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)')); ST_MemSize ---------- 80 ST_Summary 作用：以一个标准化的字符串描述一个图形的概要信息。 关键字： M: 图形坐标含有M值 Z: 图形坐标含有Z值 B: 有缓存bbox G: 图形为大地坐标 (geography) S: 图形有空间坐标系 SELECT ST_Summary(ST_GeomFromText('LINESTRING(0 0, 1 1)')) as geom1, ST_Summary(ST_GeomFromText('LINESTRINGM(0 0 0, 1 1 1)')) as geom2; geom1 | geom2 -------------------------------------------------------- LineString[] with 2 points | LineString[M] with 2 points select ST_Summary(ST_GeomFromText('LINESTRINGZ(0 0 0, 1 1 1)')) as geom3,ST_Summary(ST_GeomFromText('LINESTRING(0 0, 1 1)',4326)) as geom4; geom3 | geom4 -------------------------------------------------------- LineString[Z] with 2 points | LineString[S] with 2 points select ST_Summary(ST_GeogFromText('POLYGON((0 0, 1 1, 1 2, 1 1, 0 0))')) geog; geog -------------------------------- Polygon[BGS] with 1 ring: ring 0 has 5 points 注意：pg中数组都是从1开始计数的，在ST_InteriorRingN中n=1就是第一个外环。但是在ST_Summary返回的文本串里，第一个ring序号从0开始。 ST_Dump,ST_DumpPoints,ST_DumpRings 这三个函数返回值都是geometry_dump类型（缺少类型描述）的数据集。 函数名称 | 作用 ---|--- ST_Dump | 分解复杂组合图形 ST_DumpRings | 将Polygon分解成若干ring（环） ST_DumpPoints | 将图形分解成点 ST_Dump示例： --拆分集合 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_Dump(p_geom)) AS infos FROM ( SELECT ST_GeomFromEWKT('GEOMETRYCOLLECTION(LineString(0 0, 1 1, 1 0),LineString(1 0, 0 1))') AS p_geom) AS b) as a; path | geom ----------------------------------- {1} | LINESTRING(0 0,1 1,1 0) {2} | LINESTRING(1 0,0 1) --拆分多义线 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_Dump(p_geom)) AS infos FROM ( SELECT ST_GeomFromEWKT('MultiLineString((0 0, 1 1, 1 0),(1 0, 0 1))') AS p_geom) AS b) as a; path | geom -------------------------------- {1} | LINESTRING(0 0,1 1,1 0) {2} | LINESTRING(1 0,0 1) --拆分多义面 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_Dump(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0)),((1 1,1 2,2 2,2 1,1 1)))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1} | POLYGON((0 0,3 0,3 3,0 3,0 0)) {2} | POLYGON((1 1,1 2,2 2,2 1,1 1)) ST_DumpRings示例： select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_DumpRings(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1} | POLYGON((0 0,3 0,3 3,0 3,0 0)) {2} | POLYGON((1 1,1 2,2 2,2 1,1 1)) ST_DumpPoints分解成点的时候，path数组比较特殊，例如MultiPolygon拆分点后，path格式是{polygon_idx,ring_idx,pt_idx}，分别表达目前这个点在多义面中是哪个子面哪个子环哪个子节点上；而Polygon的path格式是{ring_idx,pt_idx},描述该点在面中位于哪个子环的哪个子节点；MultiLineString的path格式是{line_idx,pt_idx}，描述该点在多义线中位于哪个子线的哪个子节点；LineString的path格式就是{pt_idx}，很好理解。综述：path是描述这个点在图形中的层级关系的。 --多义面 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_DumpPoints(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1,1,1} | POINT(0 0) {1,1,2} | POINT(3 0) {1,1,3} | POINT(3 3) {1,1,4} | POINT(0 3) {1,1,5} | POINT(0 0) {1,2,1} | POINT(1 1) {1,2,2} | POINT(1 2) {1,2,3} | POINT(2 2) {1,2,4} | POINT(2 1) {1,2,5} | POINT(1 1) --单面 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_DumpPoints(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1,1} | POINT(0 0) {1,2} | POINT(3 0) {1,3} | POINT(3 3) {1,4} | POINT(0 3) {1,5} | POINT(0 0) {2,1} | POINT(1 1) {2,2} | POINT(1 2) {2,3} | POINT(2 2) {2,4} | POINT(2 1) {2,5} | POINT(1 1) "},"8-VectorFunction/Clustering/ST_ClusterDBSCAN.html":{"url":"8-VectorFunction/Clustering/ST_ClusterDBSCAN.html","title":"8.15.1 ST_ClusterDBSCAN","keywords":"","body":"ST_ClusterDBSCAN 方法功能描述 窗口函数，基于DBSCAN算法，返回每一个输入的geometry所对应的聚类id。 函数定义 integer ST_ClusterDBSCAN(geometry winset geom, float8 eps, integer minpoints); 入参： geom：输入的2d图形。 eps：聚类距离，当两个图形之间距离小于聚类距离，他们被归为一类。 minpoints：规定“簇”中至少包含的图形数量。 返回值：对应的聚类id号，如果输入的geom不属于任何一个“簇”，将返回null。 应用示例 从osm的building图层中截取了一小部分测试房屋建筑数据，基于ST_ClusterDBSCAN方法，根据建筑之间小于20米，且每一簇中至少包含2个图形： --表坐标系是epsg:4326的经纬度，所以这里是使用0.0002大概模拟20米，非真实距离。 SELECT gid,name, ST_ClusterDBSCAN(geom, eps:= 0.0002, minpoints := 2) over () AS cid FROM buildings; gid | name | cid -----+--------------+----- 1 | | 2 | | 2 3 | | 2 4 | | 2 5 | 大洋百货 | 6 | 商茂世纪广场 | 0 7 | 华威大厦 | 2 8 | 天安保险大厦 | 2 9 | | 2 10 | | 11 | 江苏交通大厦 | 2 12 | 阳光大厦 | 13 | | 0 14 | | 2 15 | | 2 16 | | 2 17 | | 2 18 | | 1 19 | | 1 20 | | 2 21 | | 2 22 | | 2 23 | | 2 24 | | 2 25 | | 2 26 | | 2 27 | | 2 -- More -- cid是每个geom所对应建筑的聚类id号，灰色建筑是与其他图形之间距离大于20米，所以没有归入任何一个“簇”，返回的聚类id是null(cid null的记录都是灰色的)。 "},"8-VectorFunction/Clustering/ST_ClusterIntersecting.html":{"url":"8-VectorFunction/Clustering/ST_ClusterIntersecting.html","title":"8.15.2 ST_ClusterIntersecting","keywords":"","body":"ST_ClusterIntersecting 方法功能描述 聚合函数，对于输入的一个geometry集合，集合中图形之间根据“空间相交”进行聚类，最后把聚类结果聚合成一个geometry数组，数组里的每一项代表“一类”。 函数定义 geometry[] ST_ClusterIntersecting(geometry set g); 入参： g：输入的2d图形集合。 返回值：所有的图形完成聚类，每一类图形都是一个GEOMETRYCOLLECTION（图形集合）对象，所有类都塞入一个geometry数组里并返回结果。 应用示例 示例数据示意图如下： 先构造测试数据： create table building2( gid serial primary key, name text, geom geometry(Polygon,4326) ); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.77376608689 32.0424742122357,118.774542742962 32.0416518705121,118.773994515147 32.0411036426964,118.773172173423 32.0418802987687,118.77376608689 32.0424742122357))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.774222943403 32.0429310687489,118.775898083951 32.0413320709528,118.775456455989 32.0407838431371,118.774542742962 32.0416518705121,118.77376608689 32.0424742122357,118.774222943403 32.0429310687489))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.775898083951 32.0413320709528,118.777055453785 32.0402813009728,118.776629054372 32.0397635302578,118.775456455989 32.0407838431371,118.775898083951 32.0413320709528))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.771192461866 32.0393066737446,118.772684859809 32.0389259599839,118.772258460397 32.0379208756551,118.770705148252 32.0383320465169,118.771192461866 32.0393066737446))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.772258460397 32.0379208756551,118.772684859809 32.0389259599839,118.774375228908 32.0384234178194,118.773964058046 32.0375097047933,118.772258460397 32.0379208756551))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.776766111326 32.0381188468106,118.778045309563 32.0377076759488,118.778167137966 32.0373117336375,118.777695052903 32.0366721345192,118.776080826556 32.0371746766835,118.776766111326 32.0381188468106))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.778700137232 32.0380274755081,118.779857507065 32.0373878763897,118.779461564754 32.0368853342252,118.778730594333 32.0369614769774,118.778167137966 32.0373117336375,118.778045309563 32.0377076759488,118.778700137232 32.0380274755081))',4326)); 聚类结果示意图如下： 执行聚类： select st_astext(unnest(ST_ClusterIntersecting(geom))) from building2; st_astext ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- GEOMETRYCOLLECTION(POLYGON((118.77376608689 32.0424742122357,118.774542742962 32.0416518705121,118.773994515147 32.0411036426964,118.773172173423 32.0418802987687,118.77376608689 32.0424742122357)),POLYGON((118.774222943403 32.0429310687489,118.775898083951 32.0413320709528,118.775456455989 32.0407838431371,118.774542742962 32.0416518705121,118.77376608689 32.0424742122357,118.774222943403 32.0429310687489)),POLYGON((118.775898083951 32.0413320709528,118.777055453785 32.0402813009728,118.776629054372 32.0397635302578,118.775456455989 32.0407838431371,118.775898083951 32.0413320709528))) GEOMETRYCOLLECTION(POLYGON((118.771192461866 32.0393066737446,118.772684859809 32.0389259599839,118.772258460397 32.0379208756551,118.770705148252 32.0383320465169,118.771192461866 32.0393066737446)),POLYGON((118.772258460397 32.0379208756551,118.772684859809 32.0389259599839,118.774375228908 32.0384234178194,118.773964058046 32.0375097047933,118.772258460397 32.0379208756551))) GEOMETRYCOLLECTION(POLYGON((118.776766111326 32.0381188468106,118.778045309563 32.0377076759488,118.778167137966 32.0373117336375,118.777695052903 32.0366721345192,118.776080826556 32.0371746766835,118.776766111326 32.0381188468106)),POLYGON((118.778700137232 32.0380274755081,118.779857507065 32.0373878763897,118.779461564754 32.0368853342252,118.778730594333 32.0369614769774,118.778167137966 32.0373117336375,118.778045309563 32.0377076759488,118.778700137232 32.0380274755081))) (3 行记录) 使用问题 ST_ClusterIntersecting是个聚合函数，聚类的结果最后是一个geometry[]类型，没有任何属性字段，有时候我们其实聚类后，想要获取聚类图形结果与属性关系，比如我们没办法从ST_ClusterIntersecting函数的结果中输出对应的gid或者name等其他更多信息。 解决方法目前只能通过图形之间的关系去解决。 第一步：给原图形新增一列，存储一个必须在原图形内部的点： alter table building2 add column centroid geometry(point,4326); update building2 set centroid=ST_PointOnSurface(geom); 第二步：给聚类函数返回一个随机的聚类id： create extension \"uuid-ossp\"; --聚类中的每一组，都被分配了一个随机的聚类id create table temp_ClusterIntersecting( cid uuid, geom geometry ); insert into temp_ClusterIntersecting select uuid_generate_v4(),unnest(ST_ClusterIntersecting(geom)) from building2; 第三步：返回要素id和对应聚类id： select b.gid,a.cid a from temp_ClusterIntersecting a, building2 b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 4 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 5 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 6 | \"86daef2f-5cae-4a65-8208-433bf0c525e0\" 7 | \"86daef2f-5cae-4a65-8208-433bf0c525e0\" 也可以合起来写： select b.gid,a.cid from (select uuid_generate_v4() as cid,unnest(ST_ClusterIntersecting(geom)) as geom from building2) a, (select gid,ST_PointOnSurface(geom) as centroid from building2) b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 4 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 5 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 6 | \"86daef2f-5cae-4a65-8208-433bf0c525e0\" 这样，通过gid能关联得到每个记录对应的其他更多字段信息，通过cid知道哪些记录是一组的等其他操作。 注意：关于join和空间查询性能不是本节主要阐述重点，本节提出的方案是理论可行方案，但是基于实际项目和数据，存在优化空间，需要根据其他postgis优化方案进行处理。 "},"8-VectorFunction/Clustering/ST_ClusterKMeans.html":{"url":"8-VectorFunction/Clustering/ST_ClusterKMeans.html","title":"8.15.3 ST_ClusterKMeans","keywords":"","body":"ST_ClusterKMeans 方法功能描述 窗口函数，基于K-means算法，返回每一个输入的geometry所对应的聚类id。 函数定义 integer ST_ClusterKMeans(geometry winset geom, integer number_of_clusters); 入参： geom：输入的2d图形。 number_of_clusters：均值中心聚类指定“簇”的数量。 返回值：对应的聚类id号，如果输入的geom不属于任何一个“簇”，将返回null 应用示例 从osm的building图层中截取了一小部分测试房屋建筑数据，基于ST_ClusterKMeans空间聚合，指定分类数量为3，返回每个记录的id和对应的聚类id（cid）号： SELECT gid,ST_ClusterKMeans(geom,3) over () AS cid,geom FROM buildings; 指定分类数量为4： SELECT gid,ST_ClusterKMeans(geom,4) over () AS cid,geom FROM buildings; "},"8-VectorFunction/Clustering/ST_ClusterWithin.html":{"url":"8-VectorFunction/Clustering/ST_ClusterWithin.html","title":"8.15.4 ST_ClusterWithin","keywords":"","body":"ST_ClusterWithin 方法功能描述 聚合函数，对输入的图形集合，如果图形之间的距离在指定的距离内，则归并为一类。与ST_ClusterIntersecting类似，只是ST_ClusterIntersecting指定是图形必须相交，可以认为距离是0，而ST_ClusterWithin不需要图形之间相交关系，而是说即使图形不相交，但是当图形的距离在所规定的容差内，就可认为他们是一类。 函数定义 geometry[] a(geometry set g, float8 distance); 入参： g：输入的2d图形集合。 distance：距离容差。 返回值：所有的图形完成聚类，每一类图形都是一个GEOMETRYCOLLECTION（图形集合）对象，所有类都塞入一个geometry数组里并返回结果。 应用示例 从osm的building图层中截取了一小部分测试房屋建筑数据，基于ST_ClusterWithin空间聚类，指定聚类条件是图形间的距离小于50米： select unnest(ST_ClusterWithin(geom, 0.0005)) geom from buildings; 指定聚类条件是图形间的距离小于30米： select unnest(ST_ClusterWithin(geom, 0.0003)) geom from buildings; 使用问题 ST_ClusterWithin是个聚合函数，聚类的结果最后是一个geometry[]类型，没有任何属性字段，有时候我们其实聚类后，想要获取聚类图形结果与属性关系，比如我们没办法从ST_ClusterWithin函数的结果中输出对应的gid或者name等其他更多信息。 解决方法目前只能通过图形之间的关系去解决。 第一步：给原图形新增一列，存储一个必须在原图形内部的点： alter table buildings add column centroid geometry(point,4326); update buildings set centroid=ST_PointOnSurface(geom); 第二步：给聚类函数返回一个随机的聚类id： create extension \"uuid-ossp\"; --聚类中的每一组，都被分配了一个随机的聚类id create table temp_ClusterWithin( cid uuid, geom geometry ); insert into temp_ClusterWithin select uuid_generate_v4(),unnest(ST_ClusterWithin(geom，0.0005)) from buildings; 第三步：返回要素id和对应聚类id： select b.gid,a.cid a from temp_ClusterWithin a, buildings b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" (More rows) 也可以合起来写： select b.gid,a.cid from (select uuid_generate_v4() as cid,unnest(ST_ClusterWithin(geom，0.0005))) as geom from buildings) a, (select gid,ST_PointOnSurface(geom) as centroid from buildings) b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" (More rows) 这样，通过gid能关联得到每个记录对应的其他更多字段信息，通过cid知道哪些记录是一组的等其他操作。 注意：关于join和空间查询性能不是本节主要阐述重点，本节提出的方案是理论可行方案，但是基于实际项目和数据，存在优化空间，需要根据其他postgis优化方案进行处理。 "},"8-VectorFunction/Clustering/":{"url":"8-VectorFunction/Clustering/","title":"8.15 空间聚类","keywords":"","body":"PostGIS-Chinese-Manual PostGIS中文手册，富含大量实际案例和使用场景。 一 安装环境： 1.1 安装nodejs 1.2 全局安装gitbook npm install gitbook-cli -g 1.3 获取仓库并安装启动插件 git clone git@github.com:FreeGIS/PostGIS-Chinese-Manual.git cd PostGIS-Chinese-Manual gitbook install 1.4 启动项目 gitbook serve 页面预览地址：http://localhost:4000 "},"8-VectorFunction/Accessors.html":{"url":"8-VectorFunction/Accessors.html","title":"8.4 元数据读写","keywords":"","body":"8.4 元数据读写 以下函数返回图形类型和图形类型对应的坐标和拓扑维度。 GeometryType 作用：返回图形类型字符串，字符串形式是：'POINT','LINESTRING','POLYGON','MULTIPOINT','MULTILINESTRING','MULTIPOLYGON'等等。 SELECT GeometryType(ST_GeomFromText('Point(118 32)')); geometrytype ------------------- POINT SELECT GeometryType(ST_GeomFromText('LineString(118 32,119 33)')); geometrytype ------------------- LINESTRING ST_GeometryType 作用：返回图形类型SQL_MM字符串，字符串形式是：'ST_Point','ST_Linestring','ST_Polygon','ST_MultiPoint','ST_MultiLinestring','ST_MultiPolygon'等等。 SELECT ST_GeometryType(ST_GeomFromText('Point(118 32)')); st_geometrytype ------------------- ST_Point SELECT ST_GeometryType(ST_GeomFromText('LineString(118 32,119 33)')); st_geometrytype ------------------- ST_Linestring ST_CoordDim/ST_NDims 作用：两个函数一模一样，都是返回图形坐标维度，如二维返回2，xyz,xym都返回3，xyzm返回4。 坐标形式 维度 xy 2 xyz 3 xym 3 xyzm 4 --xy SELECT ST_CoordDim(ST_GeomFromText('Point(1 2)')); st_coorddim ------------- 2 --xyz SELECT ST_CoordDim(ST_GeomFromText('PointZ(1 2 3')); st_coorddim ------------- 3 --xym SELECT ST_CoordDim(ST_GeomFromText('PointM(1 2 3')); st_coorddim ------------- 3 --xyzm SELECT ST_CoordDim(ST_GeomFromText('PointZM(1 2 2 2')); st_coorddim ------------- 4 ST_Dimension 作用：返回图形的拓扑维度，拓扑维度只区分大类，如POINT形式，子形式包括MULTIPOINT,POINTZ,POINTM,POINTZM，统统都返回0，以此类推。 几何拓扑形式 | 维度 ---|--- POINT | 0 LINESTRING | 1 POLYGON | 2 EMPTY | -1 --xy点 SELECT ST_CoordDim(ST_GeomFromText('Point(1 2)')); ST_Dimension ------------- 0 --multi点 SELECT ST_CoordDim(ST_GeomFromText('MultiPoint(1 2,3 4)')); ST_Dimension ------------- 0 --xyz点 SELECT ST_CoordDim(ST_GeomFromText('PointZ(1 2 3')); ST_Dimension ------------- 0 --xym点 SELECT ST_CoordDim(ST_GeomFromText('PointM(1 2 3')); ST_Dimension ------------- 0 --xyzm点 SELECT ST_CoordDim(ST_GeomFromText('PointZM(1 2 2 2')); ST_Dimension ------------- 0 --linestring SELECT ST_CoordDim(ST_GeomFromText('LineString(1 2,3 4)')); ST_Dimension ------------- 1 --polygon SELECT ST_CoordDim(ST_GeomFromText('Polygon((0 0,0 1,1 1,1 0,0 0))')); ST_Dimension ------------- 2 对于类型不明确的，如GEOMETRYCOLLECTION，会选择集合里维度最高的子图形，将该子图形的图形拓扑维度返回： SELECT ST_Dimension('GEOMETRYCOLLECTION(LINESTRING(1 1,0 0),POINT(0 0))'); ST_Dimension ----------- 1 SELECT ST_Dimension('GEOMETRYCOLLECTION(Polygon((0 0,0 1,1 1,1 0,0 0)),LINESTRING(1 1,0 0),POINT(0 0))'); ST_Dimension ----------- 2 ST_Zmflag 作用：该函数主要用于测试一个图形的坐标究竟是带m还是带z值，根据其不同转态返回能提现zm状态的维度编码。 zm坐标形式 | 维度 ---|--- xy | 0 xym | 1 xyz | 2 xyzm | 3 ST_Zmflag与ST_CoordDim,ST_NDims不同，ST_CoordDim,ST_NDims中，xyz与xym都返回3，xyzm返回4，这两个函数返回值只是表达了图形坐标是几维构成，但是同样是三维，究竟是xyz还是xym是区分不了的。而通过ST_Zmflag函数，能得到准确的图形坐标究竟是xyz还是xym形式。 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRING(1 2, 3 4)')); st_zmflag ----------- 0 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGM(1 2 0, 3 4 0)')); st_zmflag ----------- 1 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGZ(1 2 0, 3 4 0)')); st_zmflag ----------- 2 SELECT ST_Zmflag(ST_GeomFromEWKT('LINESTRINGZM(1 2 0 0, 3 4 0 0)')); st_zmflag ----------- 3 --对比下ST_CoordDim,ST_NDims SELECT ST_CoordDim(ST_GeomFromEWKT('LINESTRINGZ(1 2 0, 3 4 0)')); ST_CoordDim ----------- 3 SELECT ST_CoordDim(ST_GeomFromEWKT('LINESTRINGM(1 2 0, 3 4 0)')); ST_CoordDim ----------- 3 --ST_CoordDim,ST_NDims无法区分第三维究竟是z还是m。 以下函数为测试函数，判别geometry某个属性是否具备某个状态。 ST_HasArc 作用：该函数主要用于测试一个图形是否包含圆弧。判断依据比较勉强，仅仅判断图形或者图形集合中的子图形是不是包含圆弧标志的字符串。 下例以CIRCULARSTRING(1 1, 2 2, 3 3, 4 4, 5 5)说明，这个圆弧长什么样都不知道，但是只要用CIRCULARSTRING声明其是圆弧，就会返回true。圆弧在PostGIS中其实能构造但是其他可视化软件不认识，无法可视化。该函数使用频率其实也非常低。 SELECT ST_HasArc(ST_GeomFromEWKT('CIRCULARSTRING(1 1, 2 2, 3 3, 4 4, 5 5)')); st_hasarc -------- true ST_IsPolygonCCW 作用：测试多边形是否具有逆时针方向的外环和顺时针方向的内环。 --外环是逆时针方向，内环是顺时针方向 select ST_IsPolygonCCW(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))')); ST_IsPolygonCCW ------------------- true --外环是逆时针方向，内环也是逆时针方向 select ST_IsPolygonCCW(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,2 1,2 2,1 2,1 1))')); ST_IsPolygonCCW ------------------- false ST_IsPolygonCW 作用：测试多边形是否具有顺时针方向的外环和逆时针方向的内环。 select ST_IsPolygonCW(ST_GeomFromEWKT('Polygon((0 0,0 3,3 3,3 0,0 0),(1 1,2 1,2 2,1 2,1 1))')); ST_IsPolygonCW ------------------- true ST_IsClosed 作用：判别一个线是否闭合。Polygon一定是闭合的否则构造会出错，因此，该函数常用就是判别线。所谓闭合，就是起点=终点 ，即首尾相连。 主要使用场景： SELECT ST_IsClosed(ST_GeomFromEWKT('LINESTRING(0 0, 1 1)')); st_isclosed ------------- false SELECT ST_IsClosed(ST_GeomFromEWKT('LINESTRING(0 0, 1 1,1 0,0 0)')); st_isclosed ------------- true 以下场景不常用，但是该函数也支持，并且返回结果有点差异。 多义线，每个子线都是首尾相连的： SELECT ST_IsClosed(ST_GeomFromEWKT('MULTILINESTRING((0 0, 1 1,1 0,0 0),(3 3,4 4,4 3,3 3))')); st_isclosed ------------- true 多义线，至少有个子线不是首尾相连的： SELECT ST_IsClosed(ST_GeomFromEWKT('MULTILINESTRING((0 0, 1 1,1 0,0 0),(3 3,4 4,4 3,3.5 3))')); st_isclosed ------------- true 结论：多义线实际是计算每个子线是否闭合，只有所有子线都闭合，才返回true，任意一个子线不闭合，就会返回false。 根据闭合的概念 起点=终点 那么对于点而言，起点终点就是一个点，所以一定返回true；而多义点和多义线一样，是分别计算每个子图形是否闭合，由于MultiPoint的子图形都是Point，而Point一定返回true，那么意味着于MultiPoint的子图形都是闭合的。 SELECT ST_IsClosed('POINT(0 0)'::geometry); st_isclosed ------------- true SELECT ST_IsClosed('MULTIPOINT((0 0), (1 1))'::geometry); st_isclosed ------------- true 结论： 1 对于点，多义点，该函数总是返回true。 2 对于线首尾相连认定闭合，多义线要保证每个子线都是闭合才认为多义线闭合。 3 对于面，多义面，由于面一定是闭合的，因此该函数总是返回true。 4 该函数其实仅仅用于判定LineString是否闭合为主要目的。 ST_IsCollection 作用：判定一个图形是否是集合类型，集合类型列表如下： • GEOMETRYCOLLECTION • MULTI{POINT,POLYGON,LINESTRING,CURVE,SURFACE} • COMPOUNDCURVE 当图形类型为列表类型时，该函数返回true，否则返回false。 --单线 SELECT ST_IsCollection('LINESTRING(0 0, 1 1)'::geometry); st_iscollection ------------- false --多义线 SELECT ST_IsCollection('MultiLINESTRING((0 0, 1 1))'::geometry); st_iscollection ------------- true ST_IsEmpty 作用：判定一个图形是否为空。 SELECT ST_IsEmpty(ST_GeomFromText('POLYGON EMPTY')); st_isempty ------------ true SELECT ST_IsEmpty(ST_GeomFromText('POLYGON((1 2, 3 4, 5 6, 1 2))')); st_isempty ------------ false ST_IsRing 作用：判定是否为“环”，图形中的换“环”其实是闭合的单线，比如Polygon就是一个个环组成的图形。对于“环”的定义应满足如下两点： 1 闭合的线，则ST_IsClosed(geom)=true。 2 该线不自相交，不自相切，则ST_IsSimple(geom)=true。 ​ SELECT ST_IsRing(geom), ST_IsClosed(geom), ST_IsSimple(geom) FROM (SELECT 'LINESTRING(0 0, 0 1, 1 1, 1 0, 0 0)'::geometry AS geom) AS foo; st_isring | st_isclosed | st_issimple -----------+-------------+------------- true | true | true SELECT ST_IsRing(geom), ST_IsClosed(geom), ST_IsSimple(geom) FROM (SELECT 'LINESTRING(0 0, 0 1, 1 0, 1 1, 0 0)'::geometry AS geom) AS foo; st_isring | st_isclosed | st_issimple -----------+-------------+------------- false | true | false 结论：由“环”定义可知，只有当则ST_IsClosed与则ST_IsSimple两个函数都返回true，ST_IsRing(geom)才会返回true。 ST_IsSimple 作用：判定一个图形是否自相交或者自相切。 示意图见ST_IsRing中示意图。 SELECT ST_IsSimple('LINESTRING(0 0, 0 1, 1 1, 1 0, 0 0)'::geometry); st_issimple ------------- true SELECT ST_IsSimple('LINESTRING(0 0, 0 1, 1 0, 1 1, 0 0)'::geometry); st_issimple ------------- false 以上函数为测试函数，判别geometry某个属性是否具备某个状态。 ST_Boundary 作用：返回图形边界，抽象，用例子说明。 1 对于点而言，图形边界都是empty： SELECT ST_AsText(ST_Boundary('Point(1 1)'::geometry)); st_astext ------------------------ GEOMETRYCOLLECTION EMPTY SELECT ST_AsText(ST_Boundary('MultiPoint(1 1,2 2)'::geometry)); st_astext ------------------------- GEOMETRYCOLLECTION EMPTY 2 对于未闭合线而言，图形边界是其起点和终点： SELECT ST_AsText(ST_Boundary('LINESTRING(1 1,2 2,3 -1)'::geometry)); st_astext ------------------------- MULTIPOINT(1 1,3 -1) SELECT ST_AsText(ST_Boundary('MultiLINESTRING((1 1,2 2,3 -1),(0 0,-1 -1,-2 3))'::geometry)); st_astext ------------------------------ MULTIPOINT(1 1,3 -1,0 0,-2 3) 补充：对MultiLINESTRING而言，分别计算子线的边界（起点，终点），然后把所有子线的边界（都是点）塞到一个MULTIPOINT返回。 3 对于闭合线，图形边界为空： SELECT ST_AsText(ST_Boundary('LINESTRING(1 1,2 2,3 -1,1 1)'::geometry)); st_astext ------------------------ MULTIPOINT EMPTY 4 对于面而言，图形边界是其环： 单义面： select ST_AsText(ST_Boundary(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))'))); st_astext ------------------------------------------------------------ MULTILINESTRING((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)) 多义面： select ST_AsText(ST_Boundary( ST_GeomFromEWKT('MultiPolygon(((0 0,1 0,1 1,0 1,0 0)),((2 2,2 3,3 3,3 2,2 2)))'))); st_astext ------------------------------------------------------------ MULTILINESTRING((0 0,1 0,1 1,0 1,0 0),(2 2,2 3,3 3,3 2,2 2)) ST_Envelope 作用：返回一个图形的外接矩形。点的外接矩形是Point，线面的外接矩形是个长方形Polygon，xyz的线面外接矩形仍然是xy维度里的长方形，而非官方手册说的长方体。 --点 SELECT ST_AsText(ST_Envelope('POINT(1 3)'::geometry)); st_astext ------------ POINT(1 3) --线 SELECT ST_AsText(ST_Envelope('LineString(0 0,1 1)'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) --面 SELECT ST_AsText(ST_Envelope('Polygon((0 0,1 0,1 1,0 1,0 0))'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) --xyz 线 SELECT ST_AsText(ST_Envelope('LineStringZ(0 0 0,1 1 1)'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) --xyz面 SELECT ST_AsText(ST_Envelope('PolygonZ((0 0 0,1 0 1,1 1 1,0 1 0,0 0 0))'::geometry)); st_astext ------------------------------ POLYGON((0 0,0 1,1 1,1 0,0 0)) 说明：xyz的线面返回还是二维的xy面，z轴被丢失了。 ST_Envelope与Box2D 相同点：ST_Envelope与Box2D都是获取输入图形的外接矩形。 不同点：ST_Envelope返回的是个geometry对象，如'Polygon((minx miny,minx maxy,maxx maxy,maxx miny,minx miny))::geometry'；Box2D返回的是box2d对象，如BOX(minx,miny,maxx,maxy)。 ST_BoundingDiagonal 作用：返回一个图形边界框构成的对角线。该函数会保留所有的srid和zm维度。 函数定义：ST_BoundingDiagonal(geometry geom, boolean fits=false) 参数说明：fits参数表示是否采用最佳拟合，在输入图形节点很多的情况下，fits=true则获取的边界框构成的对角线更精确点，但是稍慢；fits=false则获取的边界框范围稍大，但是速度更快。fits无论true或false，对角线构成的边界框都会覆盖输入图形（对角线的bbox>=输入图形的bbox） --xy SELECT ST_AsText(ST_BoundingDiagonal('Polygon((0 0,1 0,1 1,0 1,0 0))'::geometry)); st_astext --------------------------- LINESTRING(0 0,1 1) --xyz SELECT ST_AsText(ST_BoundingDiagonal('PolygonZ((0 0 0,1 0 1,1 1 1,0 1 0,0 0 0))'::geometry)); st_astext --------------------------- LINESTRING Z (0 0 0,1 1 1) ST_X,ST_Y,ST_Z,ST_M 作用：ST_X,ST_Y,ST_Z,ST_M四个函数分别返回Point的x，y，z，m值，入参必须是Point。 SELECT ST_X(geom), ST_Y(geom), ST_Z(geom),ST_M(geom) FROM (SELECT ST_GeomFromEWKT('POINT(1 2 3 4)') AS geom) AS foo; st_x | st_y | st_z | st_m -------------------------- 1 | 2 | 3 | 4 ST_StartPoint,ST_EndPoint 作用：ST_StartPoint,ST_EndPoint分别返回LineString或CircularLineString的起点，终点，入参必须是LineString与CircularLineString，如果是其他图形类型，返回null。 SELECT ST_AsText(ST_StartPoint(geom)) startpt, ST_AsText(ST_EndPoint(geom)) endpt FROM (SELECT ST_GeomFromEWKT('LINESTRING(0 0, 0 1, 1 0, 1 1)') AS geom) AS foo; startpt | endpt -------------------------- POINT(0 0) | POINT(1 1) SELECT ST_EndPoint('POINT(1 1)'::geometry) IS NULL AS is_null; is_null -------- true ST_NumGeometries,ST_GeometryN 作用：ST_NumGeometries返回一个图形集合中子图形的数量，ST_GeometryN返回图形集合中序号为n的子图形。两者关系类似与其他语言中获取数组的长度，根据索引返回数组中指定子项。 图形集合的概念：GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON, POLYHEDRALSURFACE。 索引序号：数据库中数组首项序号是1。与其他语言中数组首项序号为0有区别。 --获取图形集合中的子图形数量。 SELECT ST_NumGeometries(ST_GeomFromEWKT('GEOMETRYCOLLECTION( POINT(0 0), LINESTRING(0 0,1 1), POLYGON((0 0,1 0,1 1,0 1,0 0)))')); ST_NumGeometries --------------------------- 3 --获取图形集合中序号为2的子图形 SELECT ST_AsText(ST_GeometryN(ST_GeomFromEWKT('GEOMETRYCOLLECTION( POINT(0 0), LINESTRING(0 0,1 1), POLYGON((0 0,1 0,1 1,0 1,0 0)))'),2)); ST_GeometryN --------------------------- LINESTRING(0 0,1 1) --Multi类型 SELECT ST_NumGeometries(ST_GeomFromEWKT('MultiPOINT(0 0,1 1,2 2)')); ST_NumGeometries --------------------------- 3 SELECT ST_AsText(ST_GeometryN(ST_GeomFromEWKT('MultiPOINT(0 0,1 1,2 2)'),2)); ST_GeometryN --------------------------- POINT(1 1) ST_NRings,ST_ExteriorRing,ST_NumInteriorRings,ST_NumInteriorRing,ST_InteriorRingN 函数名称 作用 ST_NRings 返回Polygon的“环”数量，包括外环和内环 ST_NumInteriorRings 返回Polygon的“内环”数量 ST_NumInteriorRing 与ST_NumInteriorRings一模一样 ST_ExteriorRing 获取Polygon的外环(Polygon只有一个外环) ST_InteriorRingN 获取Polygon的指定序号的内环(Polygon可以有多个内环) 所谓“内环”就是面内组成孔洞的闭合线（孔洞边界线）。 限制说明：不用多想，只要记住这些函数仅支持Polygon类型。 --无孔洞 --该面就只有1个外环，内环数量0 SELECT ST_NRings(geom),ST_NumInteriorRings(geom) from (SELECT ST_GeomFromEWKT('Polygon((0 0,1 0,1 1,0 1,0 0))') AS geom) AS foo; ST_NRings | ST_NumInteriorRings -------------------------------------- 1 | 0 --有孔洞 --返回孔洞数量 SELECT ST_NRings(geom),ST_NumInteriorRings(geom) from (SELECT ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))') AS geom) AS foo; ST_NRings | ST_NumInteriorRings -------------------------------------- 2 | 1 --获取外环的图形 SELECT ST_AsText(ST_ExteriorRing(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))'))); ST_AsText ------------------------------- LINESTRING(0 0,3 0,3 3,0 3,0 0) --获取第一个孔洞的图形 SELECT ST_AsText(ST_InteriorRingN(ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))'),1)); ST_AsText ------------------------------- LINESTRING(1 1,1 2,2 2,2 1,1 1) ST_NRings是支持MultiPolygon的： SELECT ST_NRings(ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)))')); ST_NRings ------------ 2 PostGIS官网说ST_NumInteriorRings支持MultiPolygon，返回MultiPolygon的第一个Polygon中的内环数量，但实测发现官网是错误的，ST_NumInteriorRings对MultiPolygon返回了null： SELECT ST_NumInteriorRings(ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)))')); ST_NumInteriorRings -------------------- null 结论：除ST_NRings支持MultiPolygon外，原则上这些函数都认为是只处理Polygon类型比较好，实际也的确只是用来处理Polygon的。 ST_NumPatches,ST_PatchN 函数名称 作用 ST_NumPatches 返回多面曲面上面的数量，对非多面曲面类型返回null ST_PatchN 返回多面曲面上指定序号为n的曲面，使用ST_GeometryN可以替代ST_PatchN，结果一样且查询更快 --返回曲面多面上面的数量 SELECT ST_NumPatches(ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )')); ST_NumPatches ------------ 6 --返回曲面多面上指定序号为n的曲面 SELECT ST_AsEWKT(ST_PatchN(geom, 2)) FROM (VALUES (ST_GeomFromEWKT('POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)), ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)), ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)), ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)), ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )' )) ) As foo(geom); ST_AsEWKT ----------------------------------------- POLYGON((0 0 0,0 1 0,1 1 0,1 0 0,0 0 0)) --其实使用ST_GeometryN可以替代ST_PatchN，结果一样。 ST_NPoints,ST_NumPoints,ST_PointN,ST_Points 函数名称 作用 ST_NPoints 返回geometry上Point点数量，不仅仅针对LineString。 ST_NumPoints 返回LineString或CircularString上节点数量，不支持Multi类型。 ST_PointN 返回LineString或CircularString指定序号为n的点，n=-1是终点。 ST_Points 返回geometry上所有Point点坐标，结果为MultiPoint形式。 --ST_NPoints SELECT ST_NPoints(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)')); ST_NPoints -------------- 3 SELECT ST_NPoints(ST_GeomFromText('Polygon((1 1,1 2,2 2,2 1,1 1))')); ST_NPoints -------------- 5 --ST_NumPoints SELECT ST_NumPoints(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)')); ST_NumPoints -------------- 3 SELECT ST_NumPoints(ST_GeomFromText('Polygon((1 1,1 2,2 2,2 1,1 1))')); ST_NumPoints -------------- null --序号为2 SELECT ST_AsText(ST_PointN(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'),2)); ST_AsText -------------- POINT(2 2) --序号为0 SELECT ST_AsText(ST_PointN(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'),0)); ST_AsText -------------- null --序号为-1 SELECT ST_AsText(ST_PointN(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'),-1)); ST_AsText -------------- POINT(3 4) --ST_Points select ST_AsText(ST_Points(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)'))); ST_AsText ----------------------- MULTIPOINT(1 1,2 2,3 4) select ST_AsText(ST_Points(ST_GeomFromText('Polygon((1 1,1 2,2 2,2 1,1 1))'))); ST_AsText ------------------------------- MULTIPOINT(1 1,1 2,2 2,2 1,1 1) 结论：ST_NPoints和ST_NumPoints相同点是都获取图形的Point点数量；不同点是ST_NumPoints仅仅针对LineString或CircularString，而ST_NPoints还支持更多其他类型的图形。 ST_MemSize 作用：返回一个geom占用内存空间大小。 说明：ST_MemSize是PostgreSQL原生的pg_column_size, pg_size_pretty, pg_relation_size, pg_total_relatio_size等获取表或字段物理大小字段的补充，原因是原生函数不能准确表达geom的大小。 为什么不使用原生的pg函数去获取geometry或geom列或空间表的物理大小？由于geometry是个大对象，PG中对于大对象的物理存储提供了TOAST功能，只有了解TOAST的四种存储策略，才能理解为什么原生函数不适合，而要引入ST_MemSize，关于TOAS与PostGIS更多知识，请查看：待补充。 --单位是bytes，如果对象特别大，可以用pg_size_pretty函数显示的更人性化 --pg_size_pretty可以根据实际大小返回MB，GB等单位。 select ST_MemSize(ST_GeomFromText('LINESTRING(1 1,2 2,3 4)')); ST_MemSize ---------- 80 ST_Summary 作用：以一个标准化的字符串描述一个图形的概要信息。 关键字： M: 图形坐标含有M值 Z: 图形坐标含有Z值 B: 有缓存bbox G: 图形为大地坐标 (geography) S: 图形有空间坐标系 SELECT ST_Summary(ST_GeomFromText('LINESTRING(0 0, 1 1)')) as geom1, ST_Summary(ST_GeomFromText('LINESTRINGM(0 0 0, 1 1 1)')) as geom2; geom1 | geom2 -------------------------------------------------------- LineString[] with 2 points | LineString[M] with 2 points select ST_Summary(ST_GeomFromText('LINESTRINGZ(0 0 0, 1 1 1)')) as geom3,ST_Summary(ST_GeomFromText('LINESTRING(0 0, 1 1)',4326)) as geom4; geom3 | geom4 -------------------------------------------------------- LineString[Z] with 2 points | LineString[S] with 2 points select ST_Summary(ST_GeogFromText('POLYGON((0 0, 1 1, 1 2, 1 1, 0 0))')) geog; geog -------------------------------- Polygon[BGS] with 1 ring: ring 0 has 5 points 注意：pg中数组都是从1开始计数的，在ST_InteriorRingN中n=1就是第一个外环。但是在ST_Summary返回的文本串里，第一个ring序号从0开始。 ST_Dump,ST_DumpPoints,ST_DumpRings 这三个函数返回值都是geometry_dump类型（缺少类型描述）的数据集。 函数名称 | 作用 ---|--- ST_Dump | 分解复杂组合图形 ST_DumpRings | 将Polygon分解成若干ring（环） ST_DumpPoints | 将图形分解成点 ST_Dump示例： --拆分集合 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_Dump(p_geom)) AS infos FROM ( SELECT ST_GeomFromEWKT('GEOMETRYCOLLECTION(LineString(0 0, 1 1, 1 0),LineString(1 0, 0 1))') AS p_geom) AS b) as a; path | geom ----------------------------------- {1} | LINESTRING(0 0,1 1,1 0) {2} | LINESTRING(1 0,0 1) --拆分多义线 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_Dump(p_geom)) AS infos FROM ( SELECT ST_GeomFromEWKT('MultiLineString((0 0, 1 1, 1 0),(1 0, 0 1))') AS p_geom) AS b) as a; path | geom -------------------------------- {1} | LINESTRING(0 0,1 1,1 0) {2} | LINESTRING(1 0,0 1) --拆分多义面 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_Dump(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0)),((1 1,1 2,2 2,2 1,1 1)))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1} | POLYGON((0 0,3 0,3 3,0 3,0 0)) {2} | POLYGON((1 1,1 2,2 2,2 1,1 1)) ST_DumpRings示例： select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_DumpRings(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1} | POLYGON((0 0,3 0,3 3,0 3,0 0)) {2} | POLYGON((1 1,1 2,2 2,2 1,1 1)) ST_DumpPoints分解成点的时候，path数组比较特殊，例如MultiPolygon拆分点后，path格式是{polygon_idx,ring_idx,pt_idx}，分别表达目前这个点在多义面中是哪个子面哪个子环哪个子节点上；而Polygon的path格式是{ring_idx,pt_idx},描述该点在面中位于哪个子环的哪个子节点；MultiLineString的path格式是{line_idx,pt_idx}，描述该点在多义线中位于哪个子线的哪个子节点；LineString的path格式就是{pt_idx}，很好理解。综述：path是描述这个点在图形中的层级关系的。 --多义面 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_DumpPoints(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('MultiPolygon(((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1)))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1,1,1} | POINT(0 0) {1,1,2} | POINT(3 0) {1,1,3} | POINT(3 3) {1,1,4} | POINT(0 3) {1,1,5} | POINT(0 0) {1,2,1} | POINT(1 1) {1,2,2} | POINT(1 2) {1,2,3} | POINT(2 2) {1,2,4} | POINT(2 1) {1,2,5} | POINT(1 1) --单面 select (a.infos).path,st_astext((a.infos).geom) from (SELECT (ST_DumpPoints(p_geom)) AS infos FROM (SELECT ST_GeomFromEWKT('Polygon((0 0,3 0,3 3,0 3,0 0),(1 1,1 2,2 2,2 1,1 1))') AS p_geom) AS b) as a; path | geom --------------------------------------- {1,1} | POINT(0 0) {1,2} | POINT(3 0) {1,3} | POINT(3 3) {1,4} | POINT(0 3) {1,5} | POINT(0 0) {2,1} | POINT(1 1) {2,2} | POINT(1 2) {2,3} | POINT(2 2) {2,4} | POINT(2 1) {2,5} | POINT(1 1) "},"8-VectorFunction/Clustering.html":{"url":"8-VectorFunction/Clustering.html","title":"8.15 空间聚类","keywords":"","body":"ST_ClusterDBSCAN 方法功能描述 窗口函数，基于DBSCAN算法，返回每一个输入的geometry所对应的聚类id。 函数定义 integer ST_ClusterDBSCAN(geometry winset geom, float8 eps, integer minpoints); 入参： geom：输入的2d图形。 eps：聚类距离，当两个图形之间距离小于聚类距离，他们被归为一类。 minpoints：规定“簇”中至少包含的图形数量。 返回值：对应的聚类id号，如果输入的geom不属于任何一个“簇”，将返回null。 应用示例 从osm的building图层中截取了一小部分测试房屋建筑数据，基于ST_ClusterDBSCAN方法，根据建筑之间小于20米，且每一簇中至少包含2个图形： --表坐标系是epsg:4326的经纬度，所以这里是使用0.0002大概模拟20米，非真实距离。 SELECT gid,name, ST_ClusterDBSCAN(geom, eps:= 0.0002, minpoints := 2) over () AS cid FROM buildings; gid | name | cid -----+--------------+----- 1 | | 2 | | 2 3 | | 2 4 | | 2 5 | 大洋百货 | 6 | 商茂世纪广场 | 0 7 | 华威大厦 | 2 8 | 天安保险大厦 | 2 9 | | 2 10 | | 11 | 江苏交通大厦 | 2 12 | 阳光大厦 | 13 | | 0 14 | | 2 15 | | 2 16 | | 2 17 | | 2 18 | | 1 19 | | 1 20 | | 2 21 | | 2 22 | | 2 23 | | 2 24 | | 2 25 | | 2 26 | | 2 27 | | 2 -- More -- cid是每个geom所对应建筑的聚类id号，灰色建筑是与其他图形之间距离大于20米，所以没有归入任何一个“簇”，返回的聚类id是null(cid null的记录都是灰色的)。 ST_ClusterIntersecting 方法功能描述 聚合函数，对于输入的一个geometry集合，集合中图形之间根据“空间相交”进行聚类，最后把聚类结果聚合成一个geometry数组，数组里的每一项代表“一类”。 函数定义 geometry[] ST_ClusterIntersecting(geometry set g); 入参： g：输入的2d图形集合。 返回值：所有的图形完成聚类，每一类图形都是一个GEOMETRYCOLLECTION（图形集合）对象，所有类都塞入一个geometry数组里并返回结果。 应用示例 示例数据示意图如下： 先构造测试数据： create table building2( gid serial primary key, name text, geom geometry(Polygon,4326) ); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.77376608689 32.0424742122357,118.774542742962 32.0416518705121,118.773994515147 32.0411036426964,118.773172173423 32.0418802987687,118.77376608689 32.0424742122357))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.774222943403 32.0429310687489,118.775898083951 32.0413320709528,118.775456455989 32.0407838431371,118.774542742962 32.0416518705121,118.77376608689 32.0424742122357,118.774222943403 32.0429310687489))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.775898083951 32.0413320709528,118.777055453785 32.0402813009728,118.776629054372 32.0397635302578,118.775456455989 32.0407838431371,118.775898083951 32.0413320709528))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.771192461866 32.0393066737446,118.772684859809 32.0389259599839,118.772258460397 32.0379208756551,118.770705148252 32.0383320465169,118.771192461866 32.0393066737446))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.772258460397 32.0379208756551,118.772684859809 32.0389259599839,118.774375228908 32.0384234178194,118.773964058046 32.0375097047933,118.772258460397 32.0379208756551))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.776766111326 32.0381188468106,118.778045309563 32.0377076759488,118.778167137966 32.0373117336375,118.777695052903 32.0366721345192,118.776080826556 32.0371746766835,118.776766111326 32.0381188468106))',4326)); insert into building2(geom) values (ST_GeomFromText('POLYGON((118.778700137232 32.0380274755081,118.779857507065 32.0373878763897,118.779461564754 32.0368853342252,118.778730594333 32.0369614769774,118.778167137966 32.0373117336375,118.778045309563 32.0377076759488,118.778700137232 32.0380274755081))',4326)); 聚类结果示意图如下： 执行聚类： select st_astext(unnest(ST_ClusterIntersecting(geom))) from building2; st_astext ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- GEOMETRYCOLLECTION(POLYGON((118.77376608689 32.0424742122357,118.774542742962 32.0416518705121,118.773994515147 32.0411036426964,118.773172173423 32.0418802987687,118.77376608689 32.0424742122357)),POLYGON((118.774222943403 32.0429310687489,118.775898083951 32.0413320709528,118.775456455989 32.0407838431371,118.774542742962 32.0416518705121,118.77376608689 32.0424742122357,118.774222943403 32.0429310687489)),POLYGON((118.775898083951 32.0413320709528,118.777055453785 32.0402813009728,118.776629054372 32.0397635302578,118.775456455989 32.0407838431371,118.775898083951 32.0413320709528))) GEOMETRYCOLLECTION(POLYGON((118.771192461866 32.0393066737446,118.772684859809 32.0389259599839,118.772258460397 32.0379208756551,118.770705148252 32.0383320465169,118.771192461866 32.0393066737446)),POLYGON((118.772258460397 32.0379208756551,118.772684859809 32.0389259599839,118.774375228908 32.0384234178194,118.773964058046 32.0375097047933,118.772258460397 32.0379208756551))) GEOMETRYCOLLECTION(POLYGON((118.776766111326 32.0381188468106,118.778045309563 32.0377076759488,118.778167137966 32.0373117336375,118.777695052903 32.0366721345192,118.776080826556 32.0371746766835,118.776766111326 32.0381188468106)),POLYGON((118.778700137232 32.0380274755081,118.779857507065 32.0373878763897,118.779461564754 32.0368853342252,118.778730594333 32.0369614769774,118.778167137966 32.0373117336375,118.778045309563 32.0377076759488,118.778700137232 32.0380274755081))) (3 行记录) 使用问题 ST_ClusterIntersecting是个聚合函数，聚类的结果最后是一个geometry[]类型，没有任何属性字段，有时候我们其实聚类后，想要获取聚类图形结果与属性关系，比如我们没办法从ST_ClusterIntersecting函数的结果中输出对应的gid或者name等其他更多信息。 解决方法目前只能通过图形之间的关系去解决。 第一步：给原图形新增一列，存储一个必须在原图形内部的点： alter table building2 add column centroid geometry(point,4326); update building2 set centroid=ST_PointOnSurface(geom); 第二步：给聚类函数返回一个随机的聚类id： create extension \"uuid-ossp\"; --聚类中的每一组，都被分配了一个随机的聚类id create table temp_ClusterIntersecting( cid uuid, geom geometry ); insert into temp_ClusterIntersecting select uuid_generate_v4(),unnest(ST_ClusterIntersecting(geom)) from building2; 第三步：返回要素id和对应聚类id： select b.gid,a.cid a from temp_ClusterIntersecting a, building2 b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 4 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 5 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 6 | \"86daef2f-5cae-4a65-8208-433bf0c525e0\" 7 | \"86daef2f-5cae-4a65-8208-433bf0c525e0\" 也可以合起来写： select b.gid,a.cid from (select uuid_generate_v4() as cid,unnest(ST_ClusterIntersecting(geom)) as geom from building2) a, (select gid,ST_PointOnSurface(geom) as centroid from building2) b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 4 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 5 | \"94c281e0-4667-4557-88ab-8ca927ebfe94\" 6 | \"86daef2f-5cae-4a65-8208-433bf0c525e0\" 这样，通过gid能关联得到每个记录对应的其他更多字段信息，通过cid知道哪些记录是一组的等其他操作。 注意：关于join和空间查询性能不是本节主要阐述重点，本节提出的方案是理论可行方案，但是基于实际项目和数据，存在优化空间，需要根据其他postgis优化方案进行处理。 ST_ClusterKMeans 方法功能描述 窗口函数，基于K-means算法，返回每一个输入的geometry所对应的聚类id。 函数定义 integer ST_ClusterKMeans(geometry winset geom, integer number_of_clusters); 入参： geom：输入的2d图形。 number_of_clusters：均值中心聚类指定“簇”的数量。 返回值：对应的聚类id号，如果输入的geom不属于任何一个“簇”，将返回null 应用示例 从osm的building图层中截取了一小部分测试房屋建筑数据，基于ST_ClusterKMeans空间聚合，指定分类数量为3，返回每个记录的id和对应的聚类id（cid）号： SELECT gid,ST_ClusterKMeans(geom,3) over () AS cid,geom FROM buildings; 指定分类数量为4： SELECT gid,ST_ClusterKMeans(geom,4) over () AS cid,geom FROM buildings; ST_ClusterWithin 方法功能描述 聚合函数，对输入的图形集合，如果图形之间的距离在指定的距离内，则归并为一类。与ST_ClusterIntersecting类似，只是ST_ClusterIntersecting指定是图形必须相交，可以认为距离是0，而ST_ClusterWithin不需要图形之间相交关系，而是说即使图形不相交，但是当图形的距离在所规定的容差内，就可认为他们是一类。 函数定义 geometry[] a(geometry set g, float8 distance); 入参： g：输入的2d图形集合。 distance：距离容差。 返回值：所有的图形完成聚类，每一类图形都是一个GEOMETRYCOLLECTION（图形集合）对象，所有类都塞入一个geometry数组里并返回结果。 应用示例 从osm的building图层中截取了一小部分测试房屋建筑数据，基于ST_ClusterWithin空间聚类，指定聚类条件是图形间的距离小于50米： select unnest(ST_ClusterWithin(geom, 0.0005)) geom from buildings; 指定聚类条件是图形间的距离小于30米： select unnest(ST_ClusterWithin(geom, 0.0003)) geom from buildings; 使用问题 ST_ClusterWithin是个聚合函数，聚类的结果最后是一个geometry[]类型，没有任何属性字段，有时候我们其实聚类后，想要获取聚类图形结果与属性关系，比如我们没办法从ST_ClusterWithin函数的结果中输出对应的gid或者name等其他更多信息。 解决方法目前只能通过图形之间的关系去解决。 第一步：给原图形新增一列，存储一个必须在原图形内部的点： alter table buildings add column centroid geometry(point,4326); update buildings set centroid=ST_PointOnSurface(geom); 第二步：给聚类函数返回一个随机的聚类id： create extension \"uuid-ossp\"; --聚类中的每一组，都被分配了一个随机的聚类id create table temp_ClusterWithin( cid uuid, geom geometry ); insert into temp_ClusterWithin select uuid_generate_v4(),unnest(ST_ClusterWithin(geom，0.0005)) from buildings; 第三步：返回要素id和对应聚类id： select b.gid,a.cid a from temp_ClusterWithin a, buildings b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" (More rows) 也可以合起来写： select b.gid,a.cid from (select uuid_generate_v4() as cid,unnest(ST_ClusterWithin(geom，0.0005))) as geom from buildings) a, (select gid,ST_PointOnSurface(geom) as centroid from buildings) b where st_intersects(b.centroid,a.geom); gid | cid ----------------------------------- 1 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 2 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" 3 | \"d0d3a0db-41e4-4858-a98a-3279cf776fce\" (More rows) 这样，通过gid能关联得到每个记录对应的其他更多字段信息，通过cid知道哪些记录是一组的等其他操作。 注意：关于join和空间查询性能不是本节主要阐述重点，本节提出的方案是理论可行方案，但是基于实际项目和数据，存在优化空间，需要根据其他postgis优化方案进行处理。 "}}